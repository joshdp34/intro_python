[
  {
    "objectID": "22_SQL.html#introduction",
    "href": "22_SQL.html#introduction",
    "title": "22  Using SQL with Python",
    "section": "22.1 Introduction",
    "text": "22.1 Introduction\nStructured Query Language (SQL) is the standard language for managing and manipulating relational databases. A relational database is a collection of data organized into tables, where each table consists of rows (records) and columns (attributes). This structured approach ensures data consistency and enables powerful querying capabilities, meaning the ability to retrieve specific, relevant data efficiently and effectively. Querying capabilities allow users to ask detailed questions about the data, such as finding all students in a particular major or calculating the average age of students. These capabilities are enhanced by establishing relationships between tables through unique identifiers known as keys, which link related information across different tables. For example, a university database might have separate tables for students and courses, with a relationship defined by a common student ID.\nPython’s versatility allows it to interface seamlessly with SQL, providing powerful tools for querying, analyzing, and manipulating data. This chapter explores how Python interacts with databases, focusing on the sqlite3 module for SQLite databases, which are lightweight, self-contained, and require no additional server setup."
  },
  {
    "objectID": "21_Git.html#introduction-to-git-and-version-control",
    "href": "21_Git.html#introduction-to-git-and-version-control",
    "title": "21  Version Control with Git and GitHub",
    "section": "21.1 Introduction to Git and Version Control",
    "text": "21.1 Introduction to Git and Version Control\nVersion control systems (VCS) are essential tools in modern programming, providing a framework to manage, track, and organize code changes over time. Git, a distributed version control system, allows users to create multiple versions of a project, facilitating collaboration and simplifying the process of managing historical changes. Created by Linus Torvalds in 2005, Git has become a cornerstone in software development, with GitHub providing a popular web-based platform for Git repositories, enabling sharing and collaborative coding.\nFor statisticians and mathematicians, Git and GitHub offer streamlined methods for managing code, facilitating collaboration, and ensuring reproducibility. Git enables tracking modifications and maintaining a clear history, while GitHub offers remote storage, a web interface, and collaboration features, making it ideal for both individual and team projects."
  },
  {
    "objectID": "21_Git.html#setting-up-git-and-github",
    "href": "21_Git.html#setting-up-git-and-github",
    "title": "21  Version Control with Git and GitHub",
    "section": "21.2 Setting Up Git and GitHub",
    "text": "21.2 Setting Up Git and GitHub\nGit and GitHub work together to streamline version control both locally and remotely. This section will guide you through setting up Git, creating a GitHub account, and connecting Git with GitHub, so you can start tracking and sharing your code.\n\n21.2.1 Installing Git\nGit must be installed on your computer to work with version control locally. Installation instructions vary based on operating system:\n\nWindows:\n\nGo to the official Git website at git-scm.com and click on the “Download for Windows” button.\nRun the downloaded installer file. During installation, you will see multiple configuration options. For beginners, the default settings are generally appropriate. However, ensure the “Git Bash Here” option is enabled, as it provides a command-line interface for Git commands.\nOnce installed, open Git Bash by searching for it in your Start menu, and type the following command to verify the installation:\ngit --version\nThis should display the installed version of Git.\n\nmacOS:\n\nGit is often pre-installed on macOS. You can check by opening Terminal and typing:\ngit --version\nIf it is not installed, Git can be installed using Homebrew, a package manager for macOS. If Homebrew is not already installed, visit brew.sh and follow the instructions.\nInstall Git by opening Terminal and typing:\nbrew install git\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWith Git installed, you are ready to initialize repositories and start tracking changes in your projects.\n\n\n21.2.2 Creating a GitHub Account\nGitHub is an online platform where you can store and share your Git repositories. Creating an account is straightforward:\n\nGo to GitHub.com and click “Sign Up.”\nFollow the on-screen instructions to complete the account creation, including verifying your email and setting up a secure password.\nGitHub will also prompt you to create your first repository. You can skip this step for now if you want to create a repository directly from your local Git setup.\n\nAfter signing up, you’ll want to generate a Personal Access Token (PAT) for secure access between Git and GitHub. This token replaces your password when using Git on the command line or in IDEs.\nGenerating a Personal Access Token (PAT):\n\nIn GitHub, go to Settings &gt; Developer settings &gt; Personal access tokens.\nClick Generate new token, give it a descriptive name, and select appropriate permissions. For most uses, choose repo (for full control over repositories) and workflow (for CI/CD workflows).\nCopy and save the token somewhere secure, as it will only be displayed once. This token will be required for any remote pushes or fetches involving your GitHub repositories.\n\n\n\n21.2.3 Configuring Git with GitHub\nBefore you can interact with GitHub, it is important to set up Git with your GitHub credentials. This helps Git identify you and ensures all commits are associated with your GitHub profile.\n\nSet Your Username and Email Address\nThe first time you set up Git, configure your username and email. This information will be attached to all your commits.\ngit config --global user.name \"your_username\"\ngit config --global user.email \"your_email@example.com\"\nVerify the Configuration\nTo verify that your username and email have been correctly set, you can view the configuration with:\ngit config --list\nThis command will display your Git settings, confirming the username and email that will appear on all commits.\nCaching GitHub Credentials\nTo avoid entering your PAT each time you push or pull from GitHub, you can cache your credentials. Git offers a credentials helper to store your PAT securely:\n\nmacOS:\ngit config --global credential.helper osxkeychain\nWindows:\ngit config --global credential.helper wincred\n\n\n\n\n\nTesting the Connection to GitHub\nTo confirm Git and GitHub are configured correctly, try cloning an empty repository from GitHub. First, create an empty repository in GitHub by clicking “New” on your GitHub dashboard. Copy the repository’s URL and use the following command:\ngit clone https://github.com/your_username/your_repository.git\nIf everything is configured correctly, this command should clone the repository to your local machine without errors."
  },
  {
    "objectID": "21_Git.html#basic-git-commands-in-python",
    "href": "21_Git.html#basic-git-commands-in-python",
    "title": "21  Version Control with Git and GitHub",
    "section": "21.3 Basic Git Commands in Python",
    "text": "21.3 Basic Git Commands in Python\nOnce you have Git and GitHub set up, you can start using basic Git commands to track, manage, and push code changes. These commands can be run in a terminal or integrated into your Python code using libraries like GitPython. This section covers essential Git operations, including initializing a repository, staging and committing changes, and viewing repository status.\n\n21.3.1 Initializing a Repository\nCreating a Git repository is the first step in tracking changes for a new project. This action initializes a .git folder in your project directory, which will store all Git data, including your commit history and configurations.\n\nCommand Line: Navigate to your project folder and use:\ngit init\nThis command will initialize a new Git repository in the current directory.\nPython with GitPython:\nfrom git import Repo\nrepo = Repo.init(\"/path/to/your/project\")\nThis code initializes a repository in the specified directory, enabling you to start tracking changes from within Python.\n\n\n\n21.3.2 Tracking Changes with add, commit, and status\nTracking changes in Git follows a specific workflow where files are staged, committed, and reviewed. Let’s explore these steps in detail.\n\nAdding Files to the Staging Area\nBefore saving a snapshot of your changes, you must add files to the “staging area.” Staging allows you to control which files will be included in the next commit.\n\nCommand Line: Use git add to stage a file or directory. For example:\n\ngit add filename.py\nTo stage all changes in the repository, use:\ngit add .\n\nPython with GitPython:\nrepo = Repo('/path/to/your/project')\nrepo.index.add(['filename.py'])\nThis line stages the specified file. You can also add multiple files by including them in the list, e.g., ['file1.py', 'file2.py'].\n\nCommitting Changes\nA commit is a snapshot of your repository at a specific point in time. Each commit should have a message that describes the changes.\n\nCommand Line: After staging, use git commit to save your changes:\ngit commit -m \"Initial commit\"\nThe -m flag allows you to include a message that summarizes the purpose of the commit.\nPython with GitPython:\nrepo.index.commit(\"Initial commit\")\nThis line commits staged changes with the provided message.\n\nViewing the Status\nIt’s often helpful to review the current status of your repository to see which files are staged, unstaged, or untracked.\n\nCommand Line: To view the status of your repository, use:\ngit status\nThis command displays a summary of changes, showing which files are staged, unstaged, or untracked.\nPython with GitPython:\nrepo = Repo('/path/to/your/project')\nfor item in repo.index.diff(None):\n    print(item.a_path, item.change_type)\nThis Python code provides a list of files with their change types (e.g., added, modified, deleted), giving an overview of the repository’s current status.\n\n\n\n\n21.3.3 Reviewing Commit History with log\nReviewing the commit history is an important part of version control. Git allows you to see past commits, which include messages, author information, and unique commit IDs.\n\nCommand Line: Use git log to view the commit history:\ngit log\nThis command shows a list of commits in reverse chronological order. Each entry includes a commit hash, author, date, and message.\nPython with GitPython:\nfor commit in repo.iter_commits():\n    print(f\"Commit: {commit.hexsha}\\nAuthor: {commit.author.name}\\nDate: {commit.committed_datetime}\\nMessage: {commit.message}\\n\")\nThis code iterates through the commit history, displaying details for each commit. The hexsha attribute provides the unique commit ID.\n\n\n\n21.3.4 Undoing Changes with reset and checkout\nGit provides several commands to undo changes or revert to a previous state, helping to recover from mistakes or unwanted changes.\n\nUnstaging Files\nIf you accidentally added a file to the staging area, you can remove it without discarding changes.\n\nCommand Line: Use git reset to unstage: bash     git reset filename.py\nPython with GitPython: python     repo.index.remove(['filename.py'], working_tree=True)\n\nReverting to Previous Commits\nYou can roll back your repository to a previous state by checking out a previous commit. This will reset your working directory to that specific point in history.\n\nCommand Line: Use git checkout followed by the commit hash:\n\ngit checkout &lt;commit_hash&gt;\n\nPython with GitPython:\n\nrepo.git.checkout('commit_hash')\nReplace 'commit_hash' with the actual hash of the commit you want to revert to.\n\n\n\n21.3.5 Pushing and Pulling Changes with Remote Repositories\nTo collaborate with others or back up your work, you’ll need to push changes to a remote repository or pull updates from it. Let’s see how to work with remote repositories on GitHub.\n\nAdding a Remote Repository\nLinking your local Git repository to a GitHub repository allows you to sync changes.\n\nCommand Line: Use git remote add origin with the repository URL:\n\ngit remote add origin https://github.com/your_username/your_repository.git\n\nPython with GitPython:\n\norigin = repo.create_remote('origin', 'https://github.com/your_username/your_repository.git')\nPushing Changes\nAfter committing, you can push changes to GitHub to make them available remotely.\n\nCommand Line: Use git push to upload changes:\n\ngit push -u origin main\n\nPython with GitPython:\n\norigin.push()\nPulling Changes\nTo retrieve the latest changes from the remote repository, use the pull command.\n\nCommand Line:\n\ngit pull origin main\n\nPython with GitPython:\n\norigin.pull()\n\nThese commands form the foundation for using Git effectively. With these basics, you can track, commit, and sync changes locally and remotely, supporting both individual and collaborative workflows."
  },
  {
    "objectID": "22_SQL.html#why-use-sql-with-python",
    "href": "22_SQL.html#why-use-sql-with-python",
    "title": "22  Using SQL with Python",
    "section": "22.2 Why Use SQL with Python?",
    "text": "22.2 Why Use SQL with Python?\nPython is adept at data manipulation using libraries like Pandas and NumPy. However, as datasets grow in size and complexity, organizing data in a relational database and using SQL to query it becomes increasingly efficient. Combining SQL and Python has the following advantages:\n\nData Handling\nPython excels at preprocessing and visualizing data using libraries like Pandas and Matplotlib. However, SQL offers unparalleled capabilities for data retrieval and management. SQL’s structured querying system enables efficient access to specific pieces of information from large datasets. For example, a user can retrieve all records of students enrolled in a specific course without loading the entire dataset into memory.\nEfficiency\nSQL is designed to handle large datasets with optimized query execution plans. Traditional Python loops may require significant computational resources when working with extensive data, but SQL queries leverage database indexing and optimization techniques to deliver faster results. This efficiency is particularly beneficial when filtering, sorting, or aggregating data.\nScalability\nRelational databases are built to manage vast amounts of data while maintaining performance. Unlike in-memory data structures like Python lists or dictionaries, databases allow storage and retrieval of millions of records with minimal latency. This scalability ensures that data-intensive applications can grow without compromising their efficiency or integrity."
  },
  {
    "objectID": "22_SQL.html#setting-up-sqlite-in-python",
    "href": "22_SQL.html#setting-up-sqlite-in-python",
    "title": "22  Using SQL with Python",
    "section": "22.3 Setting Up SQLite in Python",
    "text": "22.3 Setting Up SQLite in Python\nSQLite is a serverless database engine that comes bundled with Python. Using SQLite, we can create, query, and manage databases without additional installation. While this chapter focuses on SQLite due to its simplicity and ease of use, Python also supports other SQL options, such as MySQL, PostgreSQL, and Microsoft SQL Server. These databases are more suitable for larger-scale applications and multi-user environments but often require additional setup and server management. By understanding SQLite, you will build a strong foundation for working with more complex SQL databases in Python. Below is an example workflow:\n\n22.3.1 Connecting to a Database\nTo begin, establish a connection to a database. SQLite is a lightweight, serverless database engine, which means it does not require a separate server process. If the specified database file does not already exist, SQLite creates it automatically upon connection. This makes SQLite ideal for testing and small-scale applications where simplicity and minimal configuration are priorities. For example, a database named example.db can be created and accessed seamlessly using Python’s sqlite3 module.\nimport sqlite3\n\n# Connect to the database (or create it if it does not exist)\nconnection = sqlite3.connect('example.db')\n\n# Create a cursor object to execute SQL commands\ncursor = connection.cursor()\n\n\n22.3.2 Creating Tables\nSQL tables provide structured storage for data by organizing information into rows and columns. Each table represents a specific entity, such as students or courses, with rows corresponding to individual records and columns defining attributes of those records (e.g., ID, name, age, and major for students). This structure allows for efficient querying and ensures data consistency by enforcing data types and constraints. Let’s create a table for storing student information:\n# Define an SQL command to create a table\ncreate_table_query = \"\"\"\nCREATE TABLE IF NOT EXISTS students (\n    id INTEGER PRIMARY KEY,\n    name TEXT NOT NULL,\n    age INTEGER,\n    major TEXT\n);\n\"\"\"\n\n# Execute the SQL command\ncursor.execute(create_table_query)\nLet’s break down the different parts of the create_table_query:\n\nCREATE TABLE IF NOT EXISTS: This command tells SQLite to create a new table only if one with the specified name does not already exist. This prevents errors from attempting to create a duplicate table.\nstudents: This is the name of the table. In this case, it represents the entity “students.”\nid INTEGER PRIMARY KEY: The id column is defined as an integer data type and marked as the primary key. The primary key ensures that each row in the table has a unique identifier, which cannot be null.\nname TEXT NOT NULL: The name column is defined as a text field that cannot contain null values. This ensures that every student in the table has a name.\nage INTEGER: The age column is defined as an integer, suitable for storing numeric values like a student’s age. Unlike name, it does not include the NOT NULL constraint, meaning it can be left empty.\nmajor TEXT: The major column is defined as a text field for storing the student’s major. It is also optional, as it does not include the NOT NULL constraint.\n\n\nAlternate Data Types and Constraints\nInstead of INTEGER or TEXT, other data types like REAL (for floating-point numbers) or BLOB (for binary data like images) could be used depending on the requirements. Additional constraints such as UNIQUE (to ensure no duplicate values), DEFAULT (to set a default value for a column), or CHECK (to enforce conditions on data) can also be added to enhance data integrity.\n\n\n\n22.3.3 Inserting Data\nThe INSERT INTO statement is used to insert new rows of data into an existing table. In the example below, we are adding a single record to the students table. Let’s break down the different parts of the code:\n\nINSERT INTO students (name, age, major): This specifies the table (students) and the columns (name, age, major) where the new data will be added. The column names must match the structure defined during the table creation.\nVALUES ('John Doe', 20, 'Mathematics'): This section provides the actual values to insert into the corresponding columns. Here, ‘John Doe’ is a string representing the name, 20 is an integer for the age, and ‘Mathematics’ is the major, stored as text.\ncursor.execute(insert_query): The execute method runs the SQL command. The insert_query variable holds the complete SQL statement.\nconnection.commit(): This ensures that the changes are saved to the database. Without this step, the data would not be permanently stored.\n\n# Insert a single record\ninsert_query = \"\"\"\nINSERT INTO students (name, age, major)\nVALUES ('John Doe', 20, 'Mathematics');\n\"\"\"\ncursor.execute(insert_query)\n\n# Commit changes to the database\nconnection.commit()\n\nAlternate Methods for Inserting Data\nYou can also use parameterized queries to avoid hardcoding values and reduce the risk of security vulnerabilities. For example:\nname, age, major = 'Jane Smith', 22, 'Physics'\ninsert_query = \"INSERT INTO students (name, age, major) VALUES (?, ?, ?);\"\ncursor.execute(insert_query, (name, age, major))\nconnection.commit()\nThis method is dynamic and safer, especially when working with user-provided data.\n\n\n\n22.3.4 Querying Data\nThe SELECT statement is one of the most commonly used SQL commands for retrieving data from a table. Let’s break down the different parts of the example below.\n\nselect_query = \"SELECT * FROM students;\": This SQL query retrieves all columns (*) and rows from the students table. The * is a wildcard that signifies selecting all available fields. For more specific queries, you can replace * with column names (e.g., SELECT name, age FROM students;).\ncursor.execute(select_query): The execute method runs the SQL query against the connected database. This step sends the query string to the database for processing.\nresults = cursor.fetchall(): The fetchall method retrieves all the rows returned by the query as a list of tuples. Each tuple represents a row in the table, with each element corresponding to a column.\nfor row in results:: This loop iterates over the result set to process and display each row.\n\n# Retrieve all students from the database\nselect_query = \"SELECT * FROM students;\"\ncursor.execute(select_query)\n\n# Fetch and display results\nresults = cursor.fetchall()\nfor row in results:\n    print(row)\n\nFiltering and Sorting Data\nYou can enhance the SELECT query to filter or sort results:\n\nFiltering: Use a WHERE clause to specify conditions, such as SELECT * FROM students WHERE age &gt; 20; to retrieve students older than 20.\nSorting: Use an ORDER BY clause, such as SELECT * FROM students ORDER BY age ASC; to sort the results by age in ascending order.\n\nThese enhancements make queries more targeted and efficient for specific analytical tasks."
  },
  {
    "objectID": "22_SQL.html#key-sql-commands",
    "href": "22_SQL.html#key-sql-commands",
    "title": "22  Using SQL with Python",
    "section": "22.4 3. Key SQL Commands",
    "text": "22.4 3. Key SQL Commands\n\nCREATE TABLE: Defines a new table.\nINSERT INTO: Adds new rows to a table.\nSELECT: Retrieves rows from a table.\nUPDATE: Modifies existing rows.\nDELETE: Removes rows from a table.\n\n\n22.4.1 Example: Updating Data\nupdate_query = \"\"\"\nUPDATE students\nSET major = 'Statistics'\nWHERE name = 'John Doe';\n\"\"\"\ncursor.execute(update_query)\nconnection.commit()\n\n\n22.4.2 Example: Deleting Data\ndelete_query = \"\"\"\nDELETE FROM students WHERE name = 'John Doe';\n\"\"\"\ncursor.execute(delete_query)\nconnection.commit()"
  },
  {
    "objectID": "22_SQL.html#using-sql-with-pandas",
    "href": "22_SQL.html#using-sql-with-pandas",
    "title": "22  Using SQL with Python",
    "section": "22.5 Using SQL with Pandas",
    "text": "22.5 Using SQL with Pandas\nPandas integrates with SQL for advanced data analysis. To load data from a database into a Pandas DataFrame:\nimport pandas as pd\n\n# Query the database and load results into a DataFrame\nquery = \"SELECT * FROM students;\"\ndf = pd.read_sql_query(query, connection)\nprint(df.head())\nSimilarly, you can export a DataFrame to an SQL table:\ndata = pd.DataFrame({\n    'name': ['Alice', 'Bob'],\n    'age': [22, 23],\n    'major': ['Computer Science', 'Physics']\n})\n\ndata.to_sql('students', connection, if_exists='append', index=False)"
  },
  {
    "objectID": "22_SQL.html#best-practices-for-using-sql-with-python",
    "href": "22_SQL.html#best-practices-for-using-sql-with-python",
    "title": "22  Using SQL with Python",
    "section": "22.6 Best Practices for Using SQL with Python",
    "text": "22.6 Best Practices for Using SQL with Python\n\nParameterized Queries: Prevent SQL security vulnerabilities by using placeholders in queries:\n\nname = 'Alice'\nquery = \"SELECT * FROM students WHERE name = ?;\"\ncursor.execute(query, (name,))\n\nClose Connections: Always close the connection to release resources:\n\nconnection.close()\n\nError Handling: Use try and except to catch and handle database errors:\n\ntry:\n    cursor.execute(\"INVALID SQL COMMAND\")\nexcept sqlite3.Error as e:\n    print(\"Error occurred:\", e)"
  },
  {
    "objectID": "22_SQL.html#exercises",
    "href": "22_SQL.html#exercises",
    "title": "22  Using SQL with Python",
    "section": "22.7 Exercises",
    "text": "22.7 Exercises\n\nExercise 1: library database\n\nCreate a database named library.db with a table books that stores the title, author, and publication year of books.\nInsert five records into the books table and retrieve all records where the publication year is after 2000.\nUpdate the author of a specific book and then delete another book from the table.\nUse Pandas to load the contents of the books table into a DataFrame, then add a new column for genres and export the updated DataFrame back to the database."
  },
  {
    "objectID": "22_SQL.html#summary",
    "href": "22_SQL.html#summary",
    "title": "22  Using SQL with Python",
    "section": "22.8 Summary",
    "text": "22.8 Summary\nThis chapter introduced the basics of using SQL with Python, focusing on SQLite and its integration with Python’s sqlite3 module. We discussed creating databases, querying data, and best practices to ensure robust and secure interactions. Combining SQL with Python expands your ability to handle and analyze large datasets efficiently, a critical skill for modern data science and statistical computing."
  },
  {
    "objectID": "22_SQL.html#updating-and-deleting",
    "href": "22_SQL.html#updating-and-deleting",
    "title": "22  Using SQL with Python",
    "section": "22.4 Updating and Deleting",
    "text": "22.4 Updating and Deleting\n\nUPDATE\nThe UPDATE command modifies existing rows in a table. For example:\nUPDATE students \nSET major = 'Statistics' \nWHERE name = 'Alice';\nThis changes the major of the student named Alice to ‘Statistics’. The WHERE clause ensures that only rows meeting the condition are updated.\n\n\nExample:\nupdate_query = \"\"\"\nUPDATE students\nSET major = 'Statistics'\nWHERE name = 'John Doe';\n\"\"\"\ncursor.execute(update_query)\nconnection.commit()\n\n\nDELETE\nThe DELETE command removes rows from a table. For example:\nDELETE FROM students WHERE name = 'Alice';\nThis deletes the record for the student named Alice. Without a WHERE clause, all rows in the table would be deleted, so it’s essential to use this command carefully.\n\n\nExample:\ndelete_query = \"\"\"\nDELETE FROM students WHERE name = 'John Doe';\n\"\"\"\ncursor.execute(delete_query)\nconnection.commit()"
  }
]