[
  {
    "objectID": "11_Data_Structures2.html#dictionaries",
    "href": "11_Data_Structures2.html#dictionaries",
    "title": "11  Data Structures: Dictionaries and Sets",
    "section": "11.1 Dictionaries",
    "text": "11.1 Dictionaries\nA dictionary in Python is a versatile and powerful data structure that stores data in key-value pairs. Unlike lists, which use numerical indices, dictionaries use keys that can be of any immutable data type (e.g., strings, numbers, tuples). This makes dictionaries an ideal structure for tasks that require fast lookups, updates, and association between related pieces of data.\n\n11.1.1 Creating a Dictionary\nDictionaries are created using curly braces {} or the dict() constructor, and key-value pairs are defined using the syntax key: value. Let’s explore various ways to create dictionaries:\n\nLiteral Notation\nThe most straightforward way to create a dictionary is by using curly braces:\n\n# Creating a dictionary with student grades\ngrades = {\n    \"John\": 85,\n    \"Alice\": 92,\n    \"Bob\": 78\n}\n\n\n\nUsing the dict() Constructor\nAlternatively, dictionaries can be created using the dict() constructor, which allows for the creation of dictionaries using keyword arguments or iterables of key-value pairs:\n\n# Creating a dictionary using keyword arguments\ngrades = dict(John=85, Alice=92, Bob=78)\n\n# Creating a dictionary from a list of tuples\ngrades = dict([(\"John\", 85), (\"Alice\", 92), (\"Bob\", 78)])\n\nIn this example, both methods create the same dictionary as the one using literal notation.\n\n\n\n11.1.2 Accessing Values\nTo access values in a dictionary, you use the key as the index. This allows for quick lookup time, which is one of the key advantages of dictionaries over lists or tuples.\n\n# Accessing the value associated with the key \"Alice\"\nprint(grades[\"Alice\"])  \n\n92\n\n\nIf the key is not found, Python raises a KeyError. To avoid this, you can use the get() method, which returns None or a specified default value if the key does not exist:\n\n# Safely accessing a key\nprint(grades.get(\"David\", \"Not Found\")) \n\nNot Found\n\n\nNote the second argument for the get method is a value that will be returned if the specified key does not exist. The default is None.\n\n\n11.1.3 Adding and Modifying Entries\nDictionaries are mutable, meaning you can add or modify key-value pairs after the dictionary has been created.\n\nModifying Values\nTo modify the value associated with an existing key, simply assign a new value to that key:\n\n# Modifying the value associated with \"John\"\ngrades[\"John\"] = 88\nprint(grades)  \n\n{'John': 88, 'Alice': 92, 'Bob': 78}\n\n\n\n\nAdding New Key-Value Pairs\nTo add a new key-value pair, use the same syntax as modifying an existing pair:\n\n# Adding a new key-value pair\ngrades[\"David\"] = 90\nprint(grades) \n\n{'John': 88, 'Alice': 92, 'Bob': 78, 'David': 90}\n\n\n\n\n\n11.1.4 Deleting Key-Value Pairs\nThere are several ways to remove key-value pairs from a dictionary:\n\nUsing the del Statement\nThe del statement removes the key-value pair from the dictionary:\n\n# Removing the key-value pair for \"Bob\"\ndel grades[\"Bob\"]\nprint(grades) \n\n{'John': 88, 'Alice': 92, 'David': 90}\n\n\n\n\nUsing the pop() Method\nThe pop() method removes a key-value pair and returns the value. If the key is not found, it raises a KeyError, unless a default value is provided.\n\n# Removing and returning the value for \"Alice\"\nalice_grade = grades.pop(\"Alice\")\nprint(alice_grade)\nprint(grades)  \n\n92\n{'John': 88, 'David': 90}\n\n\n\n\n\n11.1.5 Dictionary Methods\nDictionaries come with a variety of built-in methods that simplify common tasks, such as adding, removing, and checking for keys and values.\n\nkeys(), values(), and items()\n\nkeys() returns a view of all the keys in the dictionary.\nvalues() returns a view of all the values in the dictionary.\nitems() returns a view of all key-value pairs as tuples.\n\n\nprint(grades.keys())   \nprint(grades.values()) \nprint(grades.items()) \n\ndict_keys(['John', 'David'])\ndict_values([88, 90])\ndict_items([('John', 88), ('David', 90)])\n\n\n\n\nupdate()\nThe update() method allows you to merge two dictionaries or add key-value pairs from another iterable:\n\n# Merging dictionaries\nextra_grades = {\"Eve\": 85, \"Charlie\": 79}\ngrades.update(extra_grades)\nprint(grades) \n\n{'John': 88, 'David': 90, 'Eve': 85, 'Charlie': 79}\n\n\n\n\nclear()\nThe clear() method removes all key-value pairs from the dictionary:\n\ngrades.clear()\nprint(grades) \n\n{}\n\n\n\n\n\n11.1.6 Iterating Over Dictionaries\nThere are several ways to iterate over dictionaries, depending on whether you need keys, values, or both:\n\nIterating Over Keys\nBy default, iterating over a dictionary yields its keys:\n\nfor student in grades:\n    print(student)\n\n\n\nIterating Over Values\nYou can iterate over the values by using the values() method:\n\nfor grade in grades.values():\n    print(grade)\n\n\n\nIterating Over Key-Value Pairs\nThe items() method allows you to iterate over both keys and values simultaneously:\nfor student, grade in grades.items():\n    print(f\"{student}: {grade}\")\n\n\n\n11.1.7 Dictionary Comprehension\nLike list comprehensions, Python also supports dictionary comprehensions, which provide a concise way to create dictionaries from iterables.\n\n# Creating a dictionary of squares\nsquares = {x: x**2 for x in range(1, 6)}\nprint(squares)\n\n{1: 1, 2: 4, 3: 9, 4: 16, 5: 25}\n\n\n\n\n11.1.8 Practical Applications of Dictionaries\nDictionaries are used in a variety of real-world applications, particularly where fast lookups or associations between pieces of data are needed.\n\nFrequency Count\nOne common use of dictionaries is counting the frequency of elements in a collection. Here is an example that counts the occurrence of each character in a string:\n\ndef char_frequency(text):\n    freq = {}\n    for char in text:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n    return freq\n\ntext = \"data science\"\nprint(char_frequency(text))\n\n{'d': 1, 'a': 2, 't': 1, ' ': 1, 's': 1, 'c': 2, 'i': 1, 'e': 2, 'n': 1}\n\n\n\n\nStoring Configuration Settings\nDictionaries are often used to store configuration settings because they allow easy lookups by key:\n\nconfig = {\n    \"host\": \"localhost\",\n    \"port\": 8080,\n    \"debug\": True\n}\nprint(config[\"host\"])\n\nlocalhost\n\n\n\n\nCaching Computations\nDictionaries can be used to cache results of expensive computations to avoid recalculating them:\n\n\n\n\n\n\ncache\n\n\n\nA cache (pronounced “cash”) is memory used to store something, usually data, temporarily in a computing environment.\n\n\n\nfactorial_cache = {}\n\ndef factorial(n):\n    if n in factorial_cache:\n        return factorial_cache[n]\n    if n == 0:\n        result = 1\n    else:\n        result = n * factorial(n-1)\n    factorial_cache[n] = result\n    return result\n\nprint(factorial(5))  \nprint(factorial_cache)\n\n120\n{0: 1, 1: 1, 2: 2, 3: 6, 4: 24, 5: 120}\n\n\nBy caching the results, subsequent calls to factorial(n) for previously computed values are faster, as they avoid redundant calculations.\n\n\n\n11.1.9 Using **kwargs in Functions\nIn Python, dictionaries are often used to pass and manage named arguments to functions. One powerful feature that leverages dictionaries is the **kwargs mechanism, which allows functions to accept an arbitrary number of keyword arguments (recall Chapter 8). These keyword arguments are collected into a dictionary, which provides flexibility when you do not know in advance what arguments might be passed to a function.\nThe **kwargs construct is particularly useful when writing functions that need to accept a variable number of named parameters or when extending existing functions with new optional arguments without changing their function signature.\n\nHow **kwargs Works\nThe term kwargs stands for “keyword arguments,” and when used with **, it allows you to pass a variable number of named arguments to a function. Inside the function, these keyword arguments are captured as a dictionary.\n\ndef print_student_scores(**kwargs):\n    for student, score in kwargs.items():\n        print(f\"{student}: {score}\")\n\n# Calling the function with multiple keyword arguments\nprint_student_scores(John=85, Alice=92, Bob=78)\n\nJohn: 85\nAlice: 92\nBob: 78\n\n\nIn the example above, the function print_student_scores() accepts any number of keyword arguments and prints them. The **kwargs parameter collects the keyword arguments as a dictionary, where the keys are the argument names (John, Alice, Bob), and the values are the respective scores.\n\n\nAccessing and Using **kwargs\nOnce inside the function, **kwargs behaves like a normal dictionary. You can access, iterate over, and modify its elements just as you would with any other dictionary.\n\ndef get_student_grade(**kwargs):\n    student = kwargs.get(\"student\")\n    grade = kwargs.get(\"grade\")\n    if student and grade:\n        print(f\"{student}'s grade is {grade}\")\n    else:\n        print(\"Missing student or grade information\")\n\n# Providing student and grade as keyword arguments\nget_student_grade(student=\"John\", grade=85)\n\n# Missing one argument\nget_student_grade(student=\"Alice\")  \n\nJohn's grade is 85\nMissing student or grade information\n\n\nIn this example, the kwargs.get() method is used to safely retrieve values from the kwargs dictionary. If the key does not exist, get() returns None, which prevents the function from throwing a KeyError.\n\n\nCombining **kwargs with Regular and Positional Arguments\nYou can combine **kwargs with regular and positional arguments. However, **kwargs must always be placed after regular arguments in the function signature:\n\ndef student_info(course, **kwargs):\n    print(f\"Course: {course}\")\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\n# Calling the function with both positional and keyword arguments\nstudent_info(\"Mathematics\", name=\"John\", grade=90, age=20)\n\nCourse: Mathematics\nname: John\ngrade: 90\nage: 20\n\n\nHere, course is a regular argument, and the remaining keyword arguments (e.g., name, grade, and age) are captured into the kwargs dictionary.\n\n\nPassing a Dictionary as **kwargs\nIf you already have a dictionary of key-value pairs, you can pass it to a function using ** to unpack the dictionary into keyword arguments.\n\ndef print_details(name, age, occupation):\n    print(f\"Name: {name}, Age: {age}, Occupation: {occupation}\")\n\n# Creating a dictionary of arguments\nperson = {\"name\": \"Alice\", \"age\": 30, \"occupation\": \"Data Scientist\"}\n\n# Passing the dictionary as keyword arguments\nprint_details(**person)\n\nName: Alice, Age: 30, Occupation: Data Scientist\n\n\nIn this case, the **person syntax unpacks the dictionary into keyword arguments, allowing you to pass the dictionary directly into the function.\n\n\n**kwargs and Default Arguments\nWhile **kwargs allows for flexible keyword arguments, you can also combine it with default arguments to give function parameters some predefined behavior.\n\ndef log_message(level=\"INFO\", **kwargs):\n    message = kwargs.get(\"message\", \"No message provided\")\n    timestamp = kwargs.get(\"timestamp\", \"No timestamp\")\n    print(f\"[{level}] {timestamp}: {message}\")\n\n# Logging a message with a default level\nlog_message(message=\"System started\", timestamp=\"2023-09-12 10:00:00\")\n\n# Overriding the default level\nlog_message(level=\"ERROR\", message=\"System failure\", timestamp=\"2023-09-12 10:01:00\")\n\n[INFO] 2023-09-12 10:00:00: System started\n[ERROR] 2023-09-12 10:01:00: System failure\n\n\nIn this example, the log_message() function uses a default level of “INFO” and then utilizes **kwargs to collect additional information like the message and timestamp.\n\n\nSummary\nThe **kwargs construct provides a flexible way to pass and handle keyword arguments in Python. By collecting all keyword arguments into a dictionary, you gain the ability to write dynamic and adaptable functions. Whether used for configuration settings, logging, or passing optional parameters, **kwargs is a powerful tool that makes functions more reusable and extensible."
  },
  {
    "objectID": "11_Data_Structures2.html#sets",
    "href": "11_Data_Structures2.html#sets",
    "title": "11  Data Structures: Dictionaries and Sets",
    "section": "11.2 Sets",
    "text": "11.2 Sets\nA set in Python is an unordered collection of unique elements. This data structure is useful when you need to store distinct items and perform operations such as union, intersection, difference, or membership testing efficiently. Sets are particularly powerful when handling large datasets where duplication is unnecessary or undesirable.\n\n11.2.1 Creating a Set\nSets are created by placing items inside curly braces {} or by using the set() function. Unlike lists or dictionaries, sets do not maintain any order, and duplicate values are automatically removed. Sets can hold items of any immutable data type, such as numbers, strings, or tuples.\n\nLiteral Notation\nYou can create a set directly by enclosing a sequence of values in curly braces:\n\n# Creating a set of integers\nnumbers = {1, 2, 3, 4, 5}\nprint(numbers)  \n\n# Creating a set of strings\nfruits = {\"apple\", \"banana\", \"cherry\"}\nprint(fruits)  \n\n{1, 2, 3, 4, 5}\n{'cherry', 'banana', 'apple'}\n\n\n\n\nUsing the set() Function\nThe set() function is particularly useful when creating a set from an iterable, such as a list or a string. It automatically removes duplicates:\n\n# Creating a set from a list with duplicate values\nnumbers_list = [1, 2, 2, 3, 4, 4, 5]\nunique_numbers = set(numbers_list)\nprint(unique_numbers) \n\n# Creating a set from a string\nletters = set(\"hello\")\nprint(letters)\n\n{1, 2, 3, 4, 5}\n{'e', 'h', 'o', 'l'}\n\n\n\n\n\n11.2.2 Adding and Removing Elements\n\nAdding Elements\nYou can add elements to a set using the add() method. However, since sets do not allow duplicate values, adding an existing element has no effect:\n\n# Adding elements to a set\nfruits = {\"apple\", \"banana\"}\nfruits.add(\"cherry\")\nprint(fruits)  \n\n# Attempting to add a duplicate element\nfruits.add(\"apple\")\nprint(fruits)  \n\n{'cherry', 'banana', 'apple'}\n{'cherry', 'banana', 'apple'}\n\n\n\n\nRemoving Elements\nThere are multiple ways to remove elements from a set, including the remove(), discard(), and pop() methods:\n\nremove() raises a KeyError if the element does not exist.\ndiscard() does not raise an error if the element is not found.\npop() removes and returns an arbitrary element, as sets are unordered.\n\n\n# Removing elements using remove()\nfruits.remove(\"banana\")\nprint(fruits)  \n\n# Using discard() to remove an element safely\nfruits.discard(\"apple\")\nprint(fruits)  \n\n# Removing a random element with pop()\nrandom_fruit = fruits.pop()\nprint(random_fruit)  \nprint(fruits)  \n\n{'cherry', 'apple'}\n{'cherry'}\ncherry\nset()\n\n\n\n\n\n11.2.3 Set Operations\nOne of the most powerful features of sets is their support for mathematical operations such as union, intersection, difference, and symmetric difference. These operations are efficient and allow for concise and readable code.\n\nUnion (| or union())\nThe union operation combines all elements from two sets, excluding duplicates. This operation can be performed using the | operator or the union() method.\n\nset1 = {1, 2, 3}\nset2 = {3, 4, 5}\n\n# Using the | operator\nunion_set = set1 | set2\nprint(union_set)  \n\n# Using the union() method\nunion_set = set1.union(set2)\nprint(union_set)  \n\n{1, 2, 3, 4, 5}\n{1, 2, 3, 4, 5}\n\n\n\n\nIntersection (& or intersection())\nThe intersection operation returns only the elements that are present in both sets. It can be performed using the & operator or the intersection() method.\n\nset1 = {1, 2, 3}\nset2 = {2, 3, 4}\n\n# Using the & operator\nintersection_set = set1 & set2\nprint(intersection_set) \n\n# Using the intersection() method\nintersection_set = set1.intersection(set2)\nprint(intersection_set)  \n\n{2, 3}\n{2, 3}\n\n\n\n\nDifference (- or difference())\nThe difference operation returns the elements that are in the first set but not in the second. This can be done using the - operator or the difference() method.\n\nset1 = {1, 2, 3}\nset2 = {2, 3, 4}\n\n# Using the - operator\ndifference_set = set1 - set2\nprint(difference_set) \n\n# Using the difference() method\ndifference_set = set1.difference(set2)\nprint(difference_set)  \n\n{1}\n{1}\n\n\n\n\nSymmetric Difference (^ or symmetric_difference())\nThe symmetric difference operation returns elements that are in either of the sets but not in both. This operation can be performed using the ^ operator or the symmetric_difference() method.\n\nset1 = {1, 2, 3}\nset2 = {2, 3, 4}\n\n# Using the ^ operator\nsym_diff_set = set1 ^ set2\nprint(sym_diff_set)  \n\n# Using the symmetric_difference() method\nsym_diff_set = set1.symmetric_difference(set2)\nprint(sym_diff_set)  \n\n{1, 4}\n{1, 4}\n\n\n\n\n\n11.2.4 Checking for Subsets and Supersets\nSets also support operations that allow you to check whether one set is a subset or superset of another. These operations are particularly useful in scenarios where you need to compare sets.\n\nSubset (&lt;= or issubset())\nA set A is a subset of set B if all elements of A are also in B. You can check for subsets using the &lt;= operator or the issubset() method.\n\nset1 = {1, 2}\nset2 = {1, 2, 3, 4}\n\n# Using the &lt;= operator\nprint(set1 &lt;= set2) \n\n# Using the issubset() method\nprint(set1.issubset(set2))\n\nTrue\nTrue\n\n\n\n\nSuperset (&gt;= or issuperset())\nA set A is a superset of set B if all elements of B are also in A. You can check for supersets using the &gt;= operator or the issuperset() method.\n\nset1 = {1, 2, 3, 4}\nset2 = {1, 2}\n\n# Using the &gt;= operator\nprint(set1 &gt;= set2)  \n\n# Using the issuperset() method\nprint(set1.issuperset(set2))  \n\nTrue\nTrue\n\n\n\n\n\n11.2.5 Frozen Sets\nA frozen set is an immutable version of a set, meaning that once a frozen set is created, its elements cannot be modified (i.e., you cannot add or remove elements). Frozen sets are useful when you need a collection of unique elements that should remain constant throughout the program. You create a frozen set using the frozenset() function:\n\n# Creating a frozen set\nimmutable_set = frozenset([1, 2, 3, 4])\nprint(immutable_set)  \n\n# Attempting to add an element to a frozen set will raise an error\n# immutable_set.add(5)  # Raises AttributeError\n\nfrozenset({1, 2, 3, 4})\n\n\n\n\n11.2.6 Set Comprehensions\nPython provides a concise way to create sets using set comprehensions, similar to list comprehensions. A set comprehension is written with curly braces {} and allows you to define sets based on existing iterables, often including a filtering condition.\n\n# Creating a set of squares for numbers 1 to 5\nsquares = {x**2 for x in range(1, 6)}\nprint(squares)  \n\n# Set comprehension with a condition\neven_squares = {x**2 for x in range(1, 11) if x % 2 == 0}\nprint(even_squares)  \n\n{1, 4, 9, 16, 25}\n{64, 100, 4, 36, 16}\n\n\nSet comprehensions are a powerful tool when you need to transform or filter data while maintaining unique elements.\n\n\n11.2.7 Set Best Practices\nWhile sets are efficient for handling unique elements, there are a few best practices to keep in mind when working with sets in Python:\n\nAvoid Unnecessary Duplicates: Since sets automatically remove duplicates, there’s no need to check for duplicates before adding elements.\nUse Sets for Membership Testing: When you need to check if an item exists in a collection and the collection does not need to maintain order or allow duplicates, sets are the best choice due to their O(1) membership testing time complexity.\nChoose the Right Operation: Use set operations such as union, intersection, and difference to simplify complex data comparison tasks. These operations are more efficient than writing custom loops to achieve the same results.\n\nSets are an invaluable data structure for handling collections of unique items. Their efficiency in membership testing, combined with their ability to perform set operations such as union, intersection, and difference, makes them ideal for a wide variety of tasks, from data processing to mathematical computations. With their unordered nature and automatic deduplication, sets help simplify code and ensure efficient performance, especially when working with large datasets.\n\n\n11.2.8 Combining Dictionaries and Sets\nYou can often combine dictionaries and sets in practical applications. For example, to find unique words and their counts from a list of sentences:\n\ndef unique_words(sentences):\n    word_dict = {}\n    for sentence in sentences:\n        words = set(sentence.split())  # Use a set to find unique words\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n    return word_dict\n\nsentences = [\"data science is great\", \"data science is evolving\"]\nresult = unique_words(sentences)\nprint(result)  # Output: {'data': 2, 'science': 2, 'is': 2, 'great': 1, 'evolving': 1}\n\n{'science': 2, 'great': 1, 'is': 2, 'data': 2, 'evolving': 1}\n\n\nThis function uses sets to ensure that each word in a sentence is only counted once per sentence and then stores the results in a dictionary."
  },
  {
    "objectID": "11_Data_Structures2.html#exercises",
    "href": "11_Data_Structures2.html#exercises",
    "title": "11  Data Structures: Dictionaries and Sets",
    "section": "11.3 Exercises",
    "text": "11.3 Exercises\n\nExcersice 1: Student Grades\nWrite a function called update_grades() that accepts a dictionary of student names and their grades. The function should accept new student names and grades and update the dictionary. Finally, it should return the updated dictionary.\nExample:\ngrades = {\"John\": 85, \"Alice\": 92}\nnew_grades = {\"Bob\": 78, \"Alice\": 95}\n\nupdated_grades = update_grades(grades, **new_grades)\nprint(updated_grades)\nExpected Output:\n{\"John\": 85, \"Alice\": 95, \"Bob\": 78}\n\n\nExcersice 2: Word Frequency Counter\nWrite a function word_frequency(text) that takes a string and returns a dictionary with the frequency count of each word in the string.\nExample:\ntext = \"data science is data fun science is fun\"\nresult = word_frequency(text)\nprint(result)\nExpected Output:\n{'data': 2, 'science': 2, 'is': 2, 'fun': 2}\n\n\nExcersice 3: Dictionary of Squares\nCreate a function squares_dict(n) that generates a dictionary where the keys are numbers from 1 to n and the values are their corresponding squares.\nExample:\nprint(squares_dict(5))\nExpected Output:\n{1: 1, 2: 4, 3: 9, 4: 16, 5: 25}\n\n\nExercise 4: Merge Dictionaries\nWrite a function merge_dictionaries(*args) that accepts any number of dictionaries and merges them into a single dictionary. If a key is repeated, the value from the last dictionary should be retained.\nExample:\ndict1 = {\"a\": 1, \"b\": 2}\ndict2 = {\"b\": 3, \"c\": 4}\ndict3 = {\"d\": 5}\n\nresult = merge_dictionaries(dict1, dict2, dict3)\nprint(result)\nExpected Output:\n{'a': 1, 'b': 3, 'c': 4, 'd': 5}\n\n\nExercise 5: Remove Duplicates\nWrite a function remove_duplicates(lst) that takes a list and returns a new list with all the duplicates removed using a set.\nExample:\nnumbers = [1, 2, 2, 3, 4, 4, 5]\nprint(remove_duplicates(numbers))\nExpected Output:\n[1, 2, 3, 4, 5]\n\n\nExercise 6: Set Operations\nGiven two sets of students enrolled in two different courses, write functions to:\n\nFind students enrolled in both courses.\nFind students enrolled only in the first course.\nFind students enrolled in either course but not both.\n\nExample:\ncourse_A = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}\ncourse_B = {\"Charlie\", \"David\", \"Eve\", \"Frank\"}\n\n# Students in both courses\nprint(students_in_both(course_A, course_B))\n\n# Students only in course A\nprint(only_in_first(course_A, course_B))\n\n# Students in either course but not both\nprint(either_but_not_both(course_A, course_B))\nExpected Output:\n{'Charlie', 'David'}\n{'Alice', 'Bob'}\n{'Alice', 'Bob', 'Eve', 'Frank'}\n\n\nExercise 7: Flexible Function with **kwargs\nWrite a function student_profile(**kwargs) that accepts student information (name, age, grade, etc.) as keyword arguments and prints the information in a readable format.\nExample:\nstudent_profile(name=\"Alice\", age=20, grade=\"A\", major=\"Mathematics\")\nExpected Output:\nName: Alice\nAge: 20\nGrade: A\nMajor: Mathematics\n\n\nExercise 8: Summing Keyword Arguments\nWrite a function sum_values(**kwargs) that takes any number of keyword arguments where the values are integers and returns their sum.\nExample:\nresult = sum_values(a=5, b=10, c=3)\nprint(result)\nExpected Output:\n18\n\n\nExcersice 1: Basic List Operations\n\nCreate a list named fruits with the values: “apple”, “banana”, “cherry”.\n\nAdd the fruit “orange” to the list.\n\nRemove “banana” from the list.\n\nPrint the second fruit in the list.\n\nPrint the length of the list.\n\n\n\nExcersice 2: Modifying Lists\n\nCreate a list numbers containing the values 1, 2, 3, 4, and 5.\n\nReplace the third element in the list with the value 10.\n\nAdd the number 6 to the end of the list.\n\nInsert the number 0 at the beginning of the list.\n\nPrint the updated list.\n\n\n\nExcersice 3: Slicing Lists\nGiven the list colors = [\"red\", \"green\", \"blue\", \"yellow\", \"purple\"],\na. Slice and print the first three colors.\nb. Slice and print the last two colors.\nc. Slice and print every second color in the list.\n\n\nExcersice 4: Nested Lists\nCreate a nested list matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]].\na. Print the element at the first row and second column.\nb. Change the element at the second row and third column to 10.\nc. Print the entire second row.\n\n\nExcersice 5: Basic Tuple Operations\n\nCreate a tuple my_tuple with values: 10, 20, 30, 40, 50.\n\nPrint the value at index 2.\n\nTry to change the value at index 1 to 15 (what happens?).\n\nPrint the length of the tuple.\n\n\n\nExcersice 6: Tuple Unpacking\n\nCreate a tuple dimensions = (1920, 1080).\n\nUnpack the tuple into variables width and height.\n\nPrint the values of width and height.\n\n\n\nExcersice 7: Returning Tuples from Functions\n\nWrite a function calculate_stats(numbers) that takes a list of numbers and returns a tuple containing the sum and the average of the list.\n\nCall the function with the list [10, 20, 30, 40, 50] and unpack the returned tuple into variables total_sum and average.\n\nPrint the values of total_sum and average.\n\n\n\nExcersice 8: Nested Tuples\nGiven the nested tuple nested = ((1, 2), (3, 4), (5, 6)),\na. Print the first element of the second tuple.\nb. Try to change the second element of the third tuple to 7 (what happens?).\n\n\nExcersice 9: Basic List Comprehension\n\nCreate a list comprehension that generates a list of squares of numbers from 1 to 10.\n\nCreate a list comprehension that generates a list of even numbers between 1 and 20.\n\n\n\nExcersice 10: Basic List Comprehension\n\nCreate a list comprehension that generates a list of all numbers between 1 and 50 that are divisible by 3.\n\nCreate a list comprehension that generates a list of all numbers between 1 and 100 that are divisible by both 2 and 5.\n\n\n\nExcersice 11: Nested List Comprehension\nUsing nested list comprehension, create a list of all possible combinations of two numbers, where the first number is from the list [1, 2, 3] and the second number is from the list [4, 5, 6].\n\n\nExcersice 12: String Manipulation with List Comprehension\nGiven the list words = [\"apple\", \"banana\", \"cherry\", \"date\"],\na. Create a list comprehension that returns the lengths of each word in the list.\nb. Create a list comprehension that converts each word in the list to uppercase.\n\n\nExcersice 13: Tuples and List Comprehension\nGiven a list of tuples representing students and their scores:\nstudents = [(\"Alice\", 85), (\"Bob\", 60), (\"Charlie\", 95), (\"David\", 70)],\na. Use a list comprehension to create a list of names of students who scored 70 or above.\nb. Use a list comprehension to create a list of tuples where each student’s score is increased by 5 points.\n\n\nExcersice 14: Matrix Flattening\nGiven a nested list (matrix): matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], use list comprehension to flatten the matrix into a single list."
  },
  {
    "objectID": "08_Functions.html#defining-a-function",
    "href": "08_Functions.html#defining-a-function",
    "title": "8  Functions",
    "section": "8.1 Defining a Function",
    "text": "8.1 Defining a Function\nTo define a function in Python, you use the def keyword, followed by the function name, parentheses (), and a colon :. The function body, which contains the code to be executed, is indented beneath the function definition.\nSyntax:\ndef function_name(parameters):\n    # Function body\n    statement(s)\nExample:\n\ndef greet():\n    print(\"Hello, World!\")\n\nIn this example, the function greet() is defined to print the message “Hello, World!” when called."
  },
  {
    "objectID": "08_Functions.html#calling-a-function",
    "href": "08_Functions.html#calling-a-function",
    "title": "8  Functions",
    "section": "8.2 Calling a Function",
    "text": "8.2 Calling a Function\nOnce a function is defined, it can be called by using its name followed by parentheses ().\nExample:\n\ngreet() \n\nHello, World!\n\n\nHere, the greet() function is invoked, and the message is displayed."
  },
  {
    "objectID": "08_Functions.html#function-arguments",
    "href": "08_Functions.html#function-arguments",
    "title": "8  Functions",
    "section": "8.3 Function Arguments",
    "text": "8.3 Function Arguments\nFunctions can accept input values called arguments or parameters, allowing them to perform operations based on the input provided. These arguments are specified within the parentheses when defining the function.\n\n8.3.1 Positional Arguments\nPositional arguments are the most straightforward type of arguments. They are assigned to parameters based on their position in the function call.\nExample:\n\ndef greet(name):\n    print(f\"Hello, {name}!\")\n\ngreet(\"Alice\")\n\nHello, Alice!\n\n\n\n\n\n\n\n\nf-strings\n\n\n\nThe argument in the print() function above is called an f-string. An f-string, introduced in Python 3.6, is a way to embed expressions inside string literals using curly braces {}. The f or F before the opening quote of the string indicates that it is an f-string. This allows you to include variables or expressions directly within the string, making string formatting more concise and readable.\n\n\nPositional arguments are assigned to function parameters by their order of appearance. This means the first argument in the function call is passed to the first parameter, the second argument to the second parameter, and so on.\nExample: Consider the following function definition:\n\ndef describe_person(name, age, city):\n    print(f\"{name} is {age} years old and lives in {city}.\")\n\nIf you call this function with the following positional arguments:\ndescribe_person(\"Alice\", 30, \"New York\")\nThe function execution will map the arguments as follows:\n\nname will be assigned the value \"Alice\"\nage will be assigned the value 30\ncity will be assigned the value \"New York\"\n\nThe output will be:\nAlice is 30 years old and lives in New York.\n\nImportance of Order\nSince positional arguments rely on the order in which they are passed, swapping the order can lead to incorrect or unintended results.\nExample of Incorrect Order:\ndescribe_person(30, \"Alice\", \"New York\")\nIn this case:\n\nname will be assigned 30\nage will be assigned \"Alice\"\ncity will be assigned \"New York\"\n\nThis will produce the incorrect output:\n30 is Alice years old and lives in New York.\n\n\n\n8.3.2 Keyword Arguments\nKeyword arguments allow you to specify the values for parameters by explicitly naming them in the function call, regardless of their order.\nExample:\n\ndef greet(name, message):\n    print(f\"{message}, {name}!\")\n\ngreet(name=\"Bob\", message=\"Good morning\") \n\nGood morning, Bob!\n\n\nThe function can also be called with the order swapped but with the correct names.\n\ngreet(message=\"Good morning\", name=\"Bob\") \n\nGood morning, Bob!\n\n\nHere, the arguments are passed by specifying the parameter names, providing flexibility in the order of arguments.\n\nCombining Positional and Keyword Arguments\nPositional arguments can be combined with keyword arguments. However, when mixing them, positional arguments must always come before keyword arguments.\nExample:\n\ndescribe_person(\"Alice\", age=30, city=\"New York\")\n\nAlice is 30 years old and lives in New York.\n\n\nThis call is valid and will produce the correct output, as the positional argument \"Alice\" is followed by keyword arguments for age and city.\n\n\n\n8.3.3 Default Arguments\nDefault arguments allow you to define a function with default values for certain parameters. If no argument is provided for a parameter with a default value, the default is used.\nExample:\n\ndef greet(name, message=\"Hello\"):\n    print(f\"{message}, {name}!\")\n\ngreet(\"Charlie\")  \ngreet(\"Charlie\", \"Goodbye\") \n\nHello, Charlie!\nGoodbye, Charlie!\n\n\nIn this example, the message parameter has a default value of \"Hello\", which is used when no other value is provided.\n\n\n8.3.4 Variable-Length Arguments\nIn Python, functions are not limited to accepting a fixed number of arguments. You can design functions to accept a variable number of arguments, allowing for greater flexibility and adaptability in different scenarios. Python provides two special types of arguments for this purpose: *args for positional arguments and **kwargs for keyword arguments. We will discuss *args here and come back to **kwargs later in Chapter 11 after we discuss dictionaries.\n\n*args – Variable-Length Positional Arguments\nThe *args syntax allows a function to accept any number of positional arguments. When you use *args in a function definition, Python collects all the positional arguments passed into the function and stores them in a tuple, which is an ordered and immutable collection of items (discussed in Chapter 10). When you define a function with *args, it can handle calls with any number of positional arguments—from zero to many.\nExample:\n\ndef greet(*names):\n    for name in names:\n        print(f\"Hello, {name}!\")\n\nHere’s how this function works:\n\nIf you call greet(\"Alice\", \"Bob\", \"Charlie\"), the function will receive names as a tuple containing (\"Alice\", \"Bob\", \"Charlie\").\nThe function will then iterate over the tuple and print a greeting for each name.\n\n\ngreet(\"Alice\", \"Bob\", \"Charlie\")\n\nHello, Alice!\nHello, Bob!\nHello, Charlie!\n\n\n\nWhen to Use *args\n\nWhen the number of inputs is unknown: If you’re writing a function that might need to handle a varying number of inputs, *args is ideal.\nFor flexible APIs: In some cases, you want to provide a flexible API that allows users to pass in any number of arguments without enforcing a strict parameter count.\n\nExample: Imagine a function that calculates the total sum of an arbitrary number of numbers:\n\ndef calculate_sum(*numbers):\n    total = 0\n    for number in numbers:\n        total += number\n    return total\n\nprint(calculate_sum(1, 2, 3)) \nprint(calculate_sum(5, 10, 15, 20))\n\n6\n50\n\n\nThis function can sum any number of integers or floats, demonstrating how *args enables flexible input handling."
  },
  {
    "objectID": "08_Functions.html#return-values",
    "href": "08_Functions.html#return-values",
    "title": "8  Functions",
    "section": "8.4 Return Values",
    "text": "8.4 Return Values\nFunctions can return values using the return statement. The value returned can be assigned to a variable for further use in the program.\nExample:\n\ndef add(a, b):\n    return a + b\n\nresult = add(3, 4)\nprint(result) \n\n7\n\n\nHere, the add function returns the sum of a and b, which is then stored in the variable result.\n\n8.4.1 Returning Multiple Values\nIn Python, a function can return more than one value at a time, which is a feature that adds considerable flexibility to the way functions are used. When a function returns multiple values, it does so by returning a tuple. This allows you to return several related pieces of data from a single function call, without the need to explicitly create and manage a complex data structure.\n\nHow Multiple Return Values Work\nWhen a function is designed to return multiple values, it simply lists the values after the return keyword, separated by commas. Python automatically packages these values into a tuple. The caller of the function can then unpack this tuple (see Chapter 10) into separate variables, each receiving one of the returned values.\nExample:\nConsider the following example:\n\ndef add_subtract(a, b):\n    return a + b, a - b\n\nIn this function:\n\na + b computes the sum of the two arguments a and b.\na - b computes the difference between a and b.\nBoth values are returned together as a tuple.\n\nWhen this function is called:\n\nsum_result, diff_result = add_subtract(10, 5)\nprint(sum_result)  \nprint(diff_result)  \n\n15\n5\n\n\nHere, the tuple (15, 5) is returned, and it is immediately unpacked into the variables sum_result and diff_result. This allows the caller to easily access each result separately.\n\n\nBenefits of Returning Multiple Values\nReturning multiple values from a function is particularly advantageous in situations where a single calculation or process naturally produces more than one result.\nExample 1: Mathematical Operations\n\ndef calculate_area_perimeter(length, width):\n    area = length * width\n    perimeter = 2 * (length + width)\n    return area, perimeter\n\narea, perimeter = calculate_area_perimeter(5, 3)\nprint(f\"Area: {area}, Perimeter: {perimeter}\")\n\nArea: 15, Perimeter: 16\n\n\nIn this example, the function calculate_area_perimeter returns both the area and perimeter of a rectangle. This allows the caller to retrieve and use both pieces of information with a single function call.\nExample 2: Finding Extremes\n\ndef find_extremes(numbers):\n    return max(numbers), min(numbers)\n\nmaximum, minimum = find_extremes([10, 20, 5, 30, 15])\nprint(f\"Maximum: {maximum}, Minimum: {minimum}\")\n\nMaximum: 30, Minimum: 5\n\n\nHere, the function find_extremes computes and returns both the maximum and minimum values from a list of numbers, making it easy to handle both results simultaneously.\n\n\nUnpacking Returned Values\nWhen a function returns multiple values, the caller can unpack these values into individual variables. This is done by assigning the function call to a tuple of variables corresponding to the number of values returned.\nExample:\n\nsum_result, diff_result = add_subtract(10, 5)\n\nIn this case, the returned tuple (15, 5) is unpacked into sum_result and diff_result, making the individual results accessible immediately.\n\n\nSingle Return Value with a Tuple\nIf needed, the function can return a tuple directly without unpacking it in the calling code. This can be useful when the function’s result is intended to be passed around or used as a single entity.\nExample:\n\nresult = add_subtract(10, 5)\nprint(result) \n\n(15, 5)\n\n\nHere, the entire tuple (15, 5) is returned as a single object and can be used as such."
  },
  {
    "objectID": "08_Functions.html#best-practices-in-function-design",
    "href": "08_Functions.html#best-practices-in-function-design",
    "title": "8  Functions",
    "section": "8.5 Best Practices in Function Design",
    "text": "8.5 Best Practices in Function Design\nDesigning functions effectively is crucial for writing clean, maintainable, and efficient code. Well-designed functions not only make your code easier to understand and use but also reduce the likelihood of bugs and make it easier to extend and modify your programs. Below are some best practices to follow when designing functions in Python.\n\nUse Descriptive Names\nA function’s name should clearly and concisely describe what the function does. Descriptive names make the code more readable and self-documenting, allowing others (and your future self) to understand the purpose of the function without needing extensive comments or external documentation.\nExample:\n\ndef calculate_average(scores):\n    return sum(scores) / len(scores)\n\nIn this example, the function name calculate_average clearly indicates that the function computes the average of a list of scores. Anyone reading the code can immediately grasp the function’s purpose without needing to examine its implementation.\nWhy This Matters:\n\nReadability: Descriptive names make your code easier to read and understand.\nMaintainability: When functions are clearly named, it’s easier to locate and update the appropriate function when changes are needed.\nCollaboration: In team settings, clear function names help other developers understand and use your code correctly, reducing the potential for errors.\n\n\n\nKeep Functions Focused\nA well-designed function should perform a single, clearly defined task or a set of closely related tasks. This practice, often referred to as the “Single Responsibility Principle,” ensures that your functions are simple, modular, and reusable.\nExample:\ndef read_file(file_path):\n    # Processing logic here\n    pass\n\ndef process_data(data):\n    # Processing logic here\n    pass\n\ndef write_file(file_path, data):\n    # Processing logic here\n    pass\n\n\n\n\n\n\npass\n\n\n\nIn Python, the pass keyword is used as a placeholder in your code. It allows you to write syntactically correct code blocks where no action is required. Essentially, pass does nothing when executed. It’s particularly useful in situations where you have a code structure that requires a statement, but you haven’t decided what the specific code should be yet.\nThink of pass as a placeholder in your code that let you outline the structure of your program without having to fill in the details immediately. This can be very helpful during the initial stages of writing or when planning out complex code.\n\n\nIn this example, each function is focused on a specific task: reading a file, processing data, and writing to a file. By keeping each function focused, the code becomes more modular and easier to maintain.\nWhy This Matters:\n\nSimplicity: Functions that do one thing are easier to understand, test, and debug.\nReusability: Focused functions are more likely to be reusable in different parts of your program or even in other projects.\nMaintainability: When functions are responsible for a single task, changes to one part of the code are less likely to have unintended side effects on other parts.\n\n\n\nAvoid Side Effects\nSide effects occur when a function modifies some state or interacts with outside elements like global variables, files, or databases, which are not directly related to its inputs and outputs. While side effects are sometimes necessary, minimizing them helps ensure that functions are predictable and easier to test.\nRecall that global and local variables were first discussed in Section 4.1.\nExample of a Function with Side Effects:\n\ntotal = 0\n\ndef add_to_total(amount):\n    global total\n    total += amount\n\nIn this example, the function add_to_total modifies the global variable total, which is a side effect. This can lead to unpredictable behavior, especially in larger programs where the global state is modified by multiple functions.\nBetter Approach:\n\ndef calculate_new_total(current_total, amount):\n    return current_total + amount\n\nIn this revised example, the function calculate_new_total returns a new total based on the inputs without modifying any external state. The function is now pure, meaning its output depends only on its inputs and has no side effects.\nWhy This Matters:\n\nPredictability: Functions without side effects are easier to reason about because they produce the same output for the same input every time.\nTestability: Pure functions are easier to test since you don’t need to set up or tear down any external state.\nDebugging: Functions that don’t cause side effects are less likely to introduce hidden bugs related to state changes elsewhere in the program.\n\n\n\nDocument Your Functions\nEven with descriptive names, adding docstrings to your functions is a good practice. A docstring provides a description of the function’s purpose, parameters, and return values, making it easier for others to use your function correctly.\nExample:\ndef calculate_average(scores):\n    \"\"\"\n    Calculates the average of a list of scores.\n\n    Parameters:\n    scores (list of int/float): A list of numeric scores.\n\n    Returns:\n    float: The average of the scores.\n    \"\"\"\n    return sum(scores) / len(scores)\nWhy This Matters:\n\nClarity: Docstrings clarify how to use the function, what inputs it expects, and what outputs it provides.\nCollaboration: Docstrings make it easier for others to understand and use your code.\nSelf-Documentation: Well-documented functions serve as a form of in-code documentation, reducing the need for external documentation.\n\nBy following these best practices in function design—using descriptive names, keeping functions focused, avoiding side effects, and documenting your functions—you can create Python code that is easier to read, maintain, and extend. These practices not only improve the quality of your code but also make it more robust and reliable, facilitating collaboration and reducing the likelihood of bugs."
  },
  {
    "objectID": "08_Functions.html#exercises",
    "href": "08_Functions.html#exercises",
    "title": "8  Functions",
    "section": "8.6 Exercises",
    "text": "8.6 Exercises\n\nExercise 1: Simple Greeting Function\nWrite a function greet_user that takes a user’s name as input and prints a greeting message.\n\n\nExercise 2: Arithmetic Function\nWrite a function calculate that takes two numbers and returns their sum, difference, product, and quotient.\n\n\nExercise 3: Temperature Conversion\nWrite a function convert_temperature that converts a temperature from Celsius to Fahrenheit.\n\n\nExercise 4: Flexible Function\nWrite a function summarize that can take any number of numerical arguments and returns their sum and average."
  }
]