[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "STA 2450 Computing for Math & Stat",
    "section": "",
    "text": "Introduction\nThese are the lecture notes for STA 2450 - Computing for Math & Stat.\nPrerequisites: None\n\nCourse Description:\nComputer programming for mathematical scientists with emphasis on designing algorithms, problem solving, and coding practices. Topics include development of programs from specifications; appropriate use of data types; functions; modular program organization; documentation and style; and version control and collaborative programming."
  },
  {
    "objectID": "01_Intro_to_Programming.html#algorithms-on-computers",
    "href": "01_Intro_to_Programming.html#algorithms-on-computers",
    "title": "1  An Intro to Computing",
    "section": "1.1 Algorithms on Computers",
    "text": "1.1 Algorithms on Computers\nOne way to illustrate the concept of a recipe in a mechanical process is by designing machines specifically intended to solve certain problems. The earliest computers were fixed-program computers, meaning they were designed to solve a specific mathematical problem. Some simple computers still use this approach. For example, a four-function calculator can perform basic arithmetic but is not designed for word processing or gaming. Users cannot change their programs without replacing internal components.\nThe first modern computer to run a program was the Manchester Mark 1 in 1949. Unlike its predecessors, it was a stored-program computer. These machines store sequences of instructions that can be executed by an interpreter. This interpreter can execute any legal set of instructions, enabling it to compute anything that can be described using those instructions. The program and the data it manipulates reside in memory.\nTypically, a program counter points to a specific location in memory, and computation starts by executing the instruction at that point. Most often, the interpreter simply proceeds to the next instruction in the sequence. However, in some cases, it performs a test, and based on that test, execution may jump to another point in the sequence of instructions."
  },
  {
    "objectID": "01_Intro_to_Programming.html#programming-languages",
    "href": "01_Intro_to_Programming.html#programming-languages",
    "title": "1  An Intro to Computing",
    "section": "1.2 Programming Languages",
    "text": "1.2 Programming Languages\nTo use execute algorithms on a computer, we need a programming language to describe the sequence of instructions. The British mathematician Alan Turing devised a theoretical device in 1936 known as the Universal Turing Machine. This hypothetical computer had unlimited memory, represented by a tape on which one could write zeroes and ones. It also consisted of simple instructions for moving, reading, and writing on the tape.\nThe Church-Turing thesis posits that if a function is computable, a Turing Machine can be programmed to compute it. The “if” in the Church-Turing thesis is crucial because not all problems have computational solutions.\n\n\n\n\n\n\nNote\n\n\n\nA function or problem is considered computable if there exists a finite sequence of well-defined steps, an algorithm, that can be implemented by a computational model (such as a Turing Machine) to produce the correct output for any valid input within a finite amount of time. In other words, a problem is computable if there is a systematic method to solve it using an algorithm.\n\n\nThe Church-Turing thesis leads directly to the concept of Turing completeness. A programming language is said to be Turing complete if it can simulate a universal Turing Machine. All modern programming languages are Turing complete, meaning that anything that can be programmed in one language (e.g., Python) can also be programmed in another language (e.g., Java). While certain tasks may be easier to program in specific languages, all languages are fundamentally equal in terms of computational power."
  },
  {
    "objectID": "01_Intro_to_Programming.html#types-of-programming-languages",
    "href": "01_Intro_to_Programming.html#types-of-programming-languages",
    "title": "1  An Intro to Computing",
    "section": "1.3 Types of Programming Languages",
    "text": "1.3 Types of Programming Languages\n\n1.3.1 Low-Level vs. High-Level Languages\nLow-level languages are closer to machine language, providing little to no abstraction from a computer’s hardware. They allow direct control over the hardware and memory, making them highly efficient but also more complex to write and understand. Examples of low-level languages include Assembly language and machine code.\nLow-level languages operate with minimal abstraction which results in high-performance programs that execute faster and are more efficient in resource usage. However, this comes with the trade-off of complex and less intuitive code, requiring a deep understanding of computer architecture. Additionally, low-level programs are often platform-specific, meaning they are tailored to a particular type of processor or computer architecture.\n\nExample: Assembly Language\nMOV AX, 1   ; Move the value 1 into the AX register\nADD AX, 2   ; Add the value 2 to the AX register\nMOV BX, AX  ; Move the result from AX to BX\nHigh-level languages abstract away the details of computer hardware, allowing programmers to focus on the logic of the problem rather than the intricacies of the machine. They feature more intuitive syntax and semantics, making them easier to learn and use. Programs written in high-level languages are generally portable across different platforms with minimal modification. These languages also come with extensive libraries and frameworks that simplify complex tasks such as GUI development, web programming, and data manipulation. Although this abstraction can result in slower execution compared to low-level languages, the trade-off is often worth it for the ease of development and maintenance.\n\n\nExample: Print a greeting to the screen in Python\nprint(\"Hello, World!\")  \nLow-level languages offer greater control over hardware and performance optimization, whereas high-level languages prioritize ease of use and development speed. This means that while low-level languages generally result in faster and more efficient programs, they come at the cost of greater complexity. In contrast, high-level languages, although potentially slower, provide significant productivity benefits. Their readability and maintainability make them suitable for large-scale applications and collaborative projects. Additionally, high-level languages reduce development time due to their simplicity and the availability of powerful libraries and frameworks.\nUnderstanding the trade-offs between low-level and high-level languages is crucial for selecting the right tool for a given task. For most applications, high-level languages provide sufficient performance while dramatically simplifying development. However, for performance-critical applications, such as operating system kernels or embedded systems, low-level languages remain indispensable.\n\n\n\n1.3.2 General-Purpose vs. Domain-Specific Languages\nGeneral-purpose programming languages are highly versatile, allowing them to be used for a wide array of programming tasks, including web development, data analysis, game development, and more. They come with extensive standard libraries and frameworks that support diverse functionalities, making it easier to implement complex features. Programs written in these languages are often portable across different operating systems and platforms. Additionally, these languages usually have large communities, extensive documentation, and abundant resources for learning and troubleshooting. Examples of well-known general-purpose programming languages include Python, Java, C++, and JavaScript.\nDomain-specific Domain-specific languages (DSLs) are designed to handle specific types of tasks, offering features and abstractions directly relevant to their domain. They often allow for more concise and efficient coding within their domain, reducing the complexity and effort required to develop certain applications. However, their functionality is typically narrow, focusing on particular problem areas and lacking the versatility of general-purpose languages. Examples of well-known domain-specific languages include SQL, HTML, and MATLAB.\nGeneral-purpose languages are suitable for a wide variety of applications, providing greater flexibility and usability across many contexts. In contrast, domain-specific languages are specialized for particular tasks, making them more efficient and easier to use within their specific domains. While general-purpose languages often require learning a broader set of concepts and syntax, domain-specific languages might have a steeper but narrower learning curve focused on their particular use case.\n\n\n1.3.3 Interpreted vs. Compiled Languages\nInterpreted languages execute code directly through an interpreter, which translates high-level instructions into machine code line by line. This immediate execution provides several advantages, such as ease of debugging, as interpreted languages often generate more informative error messages, making it simpler to identify and correct issues by pointing to the exact line where an error occurred. Additionally, interpreted languages offer platform independence, allowing the same source code to run on any platform with a compatible interpreter, enhancing portability. However, interpreted programs generally run slower than compiled programs because the translation occurs at runtime. Well-known interpreted languages include Python, JavaScript, Ruby, and PHP.\nCompiled languages require the source code to be translated into machine code by a compiler before execution, producing an executable file. This pre-execution compilation results in faster execution, as the translation is completed beforehand, allowing the executable file to be directly executed by the hardware. Compilers also perform extensive checks during compilation, catching many types of errors before the program runs. However, compiled executables are specific to the target platform’s architecture, making them less portable unless recompiled for different platforms. Well-known compiled languages include C, C++, Rust, and Go.\n\nExample of C Code:\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}\nThis C code must be compiled into an executable file before it can be run.\nCompiled languages generally produce faster-running programs since the code is translated into machine language ahead of time, whereas interpreted languages tend to be slower due to on-the-fly translation. However, interpreted languages offer a quicker development cycle, allowing code to be written and tested immediately without a separate compilation step, which is advantageous for rapid prototyping and iterative development. Interpreted languages also boast better portability, as the same code can run on any platform with the appropriate interpreter, while compiled languages require recompilation for different platforms, adding complexity.\nDebugging is typically easier with interpreted languages because they provide more immediate and informative error feedback, pointing directly to issues in the source code. Although compiled languages catch many errors at compile time, their runtime error messages can be less detailed. Additionally, interpreted languages can support more dynamic programming features, such as dynamic typing and runtime evaluation of code, which can be more challenging to implement efficiently in compiled languages."
  },
  {
    "objectID": "01_Intro_to_Programming.html#intro-to-python",
    "href": "01_Intro_to_Programming.html#intro-to-python",
    "title": "1  An Intro to Computing",
    "section": "1.4 Intro to Python",
    "text": "1.4 Intro to Python\nIn this course, we will be using Python. Python is a general-purpose programming language that can be used to build almost any kind of program that does not require direct access to the computer’s hardware. However, Python is not optimal for programs with high reliability constraints or those that are built and maintained by many people over a long period.\nPython has several advantages over many other languages. It is relatively simple and easy to learn. Because Python is designed to be interpreted, it provides runtime feedback that is especially helpful for novice programmers.\nPython was first developed by Guido van Rossum in 1990. It went largely unnoticed during its first decade but gained popularity around 2000 with the release of Python 2.0. Python 3.0, released at the end of 2008, cleaned up many inconsistencies in Python 2’s design. While Python 3.0 is not backward-compatible with earlier versions, most important public domain libraries have been ported over, eliminating the need to use outdated software."
  },
  {
    "objectID": "02_Python_Install.html#installing-python",
    "href": "02_Python_Install.html#installing-python",
    "title": "2  Installing Python and Setting Up Your IDE",
    "section": "2.1 Installing Python",
    "text": "2.1 Installing Python\nTo start programming in Python, you’ll first need to install Python on your computer. Follow the instructions below based on your operating system:\nWindows:\n\nGo to the official Python website: python.org.\nClick on the “Downloads” tab.\nDownload the latest version of Python (ensure it’s a stable release).\nRun the installer and make sure to check the box that says “Add Python to PATH”.\nFollow the installation prompts.\n\nmacOS:\n\nOpen Terminal.\nUse Homebrew to install Python (if you don’t have Homebrew, you can install it from brew.sh):\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nInstall Python:\nbrew install python\n\nLinux:\n\nOpen Terminal.\nUse your package manager to install Python. For Debian-based systems like Ubuntu:\nsudo apt update\nsudo apt install python3\nFor Red Hat-based systems like Fedora:\nsudo dnf install python3\n\nTo verify the installation, open your terminal or command prompt and type:\npython --version\nYou should see the installed Python version displayed."
  },
  {
    "objectID": "02_Python_Install.html#understanding-integrated-development-environments-ides",
    "href": "02_Python_Install.html#understanding-integrated-development-environments-ides",
    "title": "2  Installing Python and Setting Up Your IDE",
    "section": "2.2 Understanding Integrated Development Environments (IDEs)",
    "text": "2.2 Understanding Integrated Development Environments (IDEs)\n\nWhat is an IDE?\nAn Integrated Development Environment (IDE) is a software application that provides comprehensive facilities to programmers for software development. An IDE typically includes:\n\nSource Code Editor: A text editor that supports code writing with features like syntax highlighting, auto-completion, and error detection.\nBuild Automation Tools: Tools that automate tasks like compiling code, packaging files, and running tests.\nDebugger: A tool that helps you test and debug your code by allowing you to step through your code, set breakpoints, and inspect variables.\n\nIDEs are designed to make the process of coding easier and more efficient by combining all the tools you need into a single application.\n\n\nBenefits of Using an IDE\nUsing an IDE offers numerous benefits and features that enhance the coding process. An IDE can significantly speed up development by providing quick access to all necessary tools, enhancing efficiency. Features like syntax highlighting and error detection help catch mistakes early, reducing the amount of debugging needed, thereby improving error reduction.\nThe convenience of having everything in one place makes it easier to manage projects, especially as they grow in size and complexity. Additionally, many IDEs include tools for version control, making it easier to track changes and collaborate with others, thus improving code management.\nKey features of an IDE streamline the coding process further. Syntax highlighting colors keywords, variables, and syntax, making the code more readable and easier to debug. Auto-completion suggests code completions as you type, helping to write code faster and avoid typos. Code navigation allows you to quickly jump to definitions, references, and files within your project. The integrated debugger lets you run your code step by step, inspect variables, and identify issues.\n\n\nPopular Python IDEs\n\nPyCharm: A powerful IDE specifically for Python development, offering advanced features and professional tools.\nRStudio: Primarily used for R programming but also supports Python, providing a familiar interface for those who use both languages.\nVisual Studio Code: A versatile code editor with extensive Python support through extensions, combining lightweight design with powerful features.\n\n\n\nChoosing an IDE\nChoosing the right IDE depends on your needs and preferences. Some factors to consider include ease of use, which refers to how intuitive and user-friendly the IDE is, and the feature set, which involves the availability of features that match your development needs. Performance is also crucial, particularly how well the IDE performs with larger projects. Additionally, consider the community and support available, including documentation, tutorials, and community support.\nWhether you use PyCharm, RStudio, or another IDE, having a good development environment can make a significant difference in your productivity and the quality of your code. A well-chosen IDE enhances your coding experience, making it easier to write, manage, and debug your projects efficiently."
  },
  {
    "objectID": "02_Python_Install.html#setting-up-your-ide",
    "href": "02_Python_Install.html#setting-up-your-ide",
    "title": "2  Installing Python and Setting Up Your IDE",
    "section": "2.3 Setting Up Your IDE",
    "text": "2.3 Setting Up Your IDE\nUsing PyCharm:\nPyCharm, developed by JetBrains, is a popular IDE specifically designed for Python programming. JetBrains, a software development company based in Prague, Czech Republic, was founded in 2000 and has since become renowned for creating intelligent, productivity-enhancing tools for software developers. The journey of PyCharm began in 2010, when JetBrains identified the need for a dedicated, feature-rich IDE for Python developers. At that time, Python was gaining significant traction due to its simplicity and versatility, and there was a growing demand for an IDE that could cater specifically to Python’s unique requirements.\nJetBrains leveraged its extensive experience in creating IDEs, such as IntelliJ IDEA for Java, to develop PyCharm. They aimed to build an IDE that would not only support the standard features expected by developers, such as code completion and debugging, but also include advanced capabilities like scientific computing support, web development frameworks, and robust version control integration. PyCharm quickly became popular within the Python community for its powerful features, intuitive user interface, and the comprehensive support it provided for various Python frameworks and libraries. Over the years, PyCharm has continued to evolve, incorporating feedback from its user base and keeping pace with the latest advancements in Python development.\nHere’s how to set up PyCharm:\n\nDownload and Install PyCharm:\n\nGo to the JetBrains website: jetbrains.com/pycharm/download.\nChoose the Community edition (it’s free).\nFollow the installation instructions for your operating system.\n\nConfiguring PyCharm:\n\nOpen PyCharm.\nSelect “New Project”.\nChoose a location for your project.\nEnsure the Python interpreter is set correctly. If Python is not listed, click on “Existing interpreter” and locate your Python installation.\nClick “Create”.\n\nWriting Your First Program:\n\nRight-click on your project folder in the Project pane.\nSelect “New” &gt; “Python File”.\nName your file (e.g., hello_world.py).\nType the following code:\nprint(\"Hello, world!\")\nRight-click on the file and select “Run” to execute your code.\n\n\nUsing RStudio:\nRStudio, developed by RStudio, PBC, is a comprehensive IDE primarily designed for the R programming language. The inception of RStudio dates back to 2008, when its founders, including JJ Allaire, sought to create a powerful tool to support the growing community of R users. R, a language and environment for statistical computing and graphics, was gaining popularity among statisticians and data scientists due to its robust capabilities for data analysis and visualization. However, the available development tools for R at that time were limited, and there was a clear need for a more sophisticated and user-friendly IDE.\nJJ Allaire, already an experienced software developer known for creating the ColdFusion web development platform, aimed to fill this gap by developing RStudio. The initial release of RStudio in 2011 was met with enthusiasm from the R community. It offered a user-friendly interface, integrating essential features like a source code editor, console, workspace, and graphics viewer within a single window. This made it significantly easier for users to write, debug, and visualize their R code.\nOver the years, RStudio has expanded its functionality to support not only R but also other programming languages like Python, enhancing its utility for data scientists and statisticians. The open-source nature of RStudio and its commitment to the R community have contributed to its widespread adoption. Today, RStudio is a central tool in data science, used by individuals and organizations worldwide for data analysis, research, and reporting.\nHere’s how to set up RStudio:\n\nDownload and Install RStudio:\n\nGo to the RStudio website: rstudio.com.\nDownload the free version for your operating system.\nFollow the installation instructions.\n\nConfiguring RStudio for Python:\n\nOpen RStudio.\nGo to “Tools” &gt; “Global Options”.\nSelect “Python” from the menu on the left.\nSet the Python interpreter to your installed Python version (e.g., /usr/bin/python3 or C:\\Python39\\python.exe).\n\nWriting Your First Program:\n\nGo to “File” &gt; “New File” &gt; “Python Script”.\nType the following code:\nprint(\"Hello, world!\")\nSave the file with a .py extension (e.g., hello_world.py).\nClick the “Run” button to execute your code.\n\n\nBy following these instructions, you’ll have Python installed and be ready to start coding with PyCharm or RStudio as your IDE."
  },
  {
    "objectID": "03_Basic_Syntax_and_Expressions.html#syntax-in-programming-languages",
    "href": "03_Basic_Syntax_and_Expressions.html#syntax-in-programming-languages",
    "title": "3  Basic Syntax and Expressions",
    "section": "3.1 Syntax in Programming Languages",
    "text": "3.1 Syntax in Programming Languages\nSyntax rules in programming languages define how the code should be written and structured. These rules ensure that the code is readable both by humans and by the computer. Just as syntax in a spoken language dictates how words and phrases should be combined to convey meaning, syntax in programming languages dictates how symbols and keywords can be combined to create valid instructions.\nKey elements of syntax include keywords, operators, punctuation, and the overall structure of statements.\n\nKeywords\nKeywords are reserved words that have special meanings in a programming language. For example, in English, words like “and,” “or,” “if,” and “then” are used to connect ideas and indicate logical relationships. Similarly, in Python, keywords like if, else, while, for, and def are used to construct control flow and define functions.\nExample in English: - “If it rains, then bring an umbrella.”\nExample in Python:\nif it_rains:\n    bring_umbrella()\n\n\nOperators\nOperators are symbols that perform operations on values. In both English and programming languages, operators are used to combine or modify elements.\nExample in English: - “Three plus five equals eight.”\nExample in Python:\n3 + 5\n\n\nPunctuation\nPunctuation marks, such as periods, commas, and parentheses, are used to group and organize sentences in English. Similarly, in programming languages, punctuation marks like parentheses (), brackets [], and braces {} are used to group and organize code.\nExample in English: - “He said, ‘Hello!’”\nExample in Python:\nprint(\"Hello!\")\n\n\nStatements and Expressions\nA statement is an instruction that the Python interpreter can execute, while an expression is a combination of values, variables, and operators that can be evaluated to produce another value. Every expression is a statement, but not every statement is an expression.\nExample in English: - “The sum of three and five is eight.” (Expression: “Three plus five”)\nExample in Python:\n3 + 5  # Expression\nprint(3 + 5)  # Statement\n\n\n\n\n\n\nNote\n\n\n\nComments in Python code are denoted by the # symbol and are used to explain and document the code. They are ignored by the Python interpreter and do not affect the execution of the program, making them useful for enhancing code readability and providing context for developers.\n\n\nUnderstanding the syntax rules in both natural and programming languages is crucial for effective communication and problem-solving. Syntax ensures that our messages, whether written in English or Python, are clear and interpretable by others, including computers."
  },
  {
    "objectID": "03_Basic_Syntax_and_Expressions.html#semantics-in-programming-languages",
    "href": "03_Basic_Syntax_and_Expressions.html#semantics-in-programming-languages",
    "title": "3  Basic Syntax and Expressions",
    "section": "3.2 Semantics in Programming Languages",
    "text": "3.2 Semantics in Programming Languages\nSemantics concerns the meaning of syntactically correct strings of symbols. In other words, while syntax is about the form, semantics is about the function. Semantics ensure that a piece of code not only adheres to the rules of the language but also performs the intended operations.\nFor instance, the expression 3 + 4 adheres to Python’s syntax rules and its semantics dictate that this expression will evaluate to 7.\nTo illustrate basic syntax and semantics, let’s look at some simple Python expressions.\n\nExample 1: Arithmetic Operations\nArithmetic operations in Python are straightforward and follow standard mathematical conventions.\n# Adding two numbers\n3 + 5\n\n# Subtracting two numbers\n10 - 4\n\n# Multiplying two numbers\n7 * 6\n\n# Dividing two numbers\n8 / 2\nEach of these expressions follows the syntax rules for arithmetic operators in Python and has clear semantics: they perform addition, subtraction, multiplication, and division, respectively.\n\n\nExample 2: Comparison Operations\nComparison operations are used to compare values and produce Boolean results (True or False).\n# Checking equality\n4 == 4\n\n# Checking inequality\n5 != 3\n\n# Checking greater than\n9 &gt; 7\n\n# Checking less than\n2 &lt; 6\nThese expressions compare two values and return a Boolean value based on the comparison.\n\n\nExample 3: Logical Operations\nLogical operations combine Boolean values and are useful in conditional expressions.\n# Logical AND\nTrue and False\n\n# Logical OR\nTrue or False\n\n# Logical NOT\nnot True\nIn these examples, logical operators evaluate the Boolean expressions and return a Boolean result.\nUnderstanding the basic syntax and semantics of a programming language is crucial for writing correct and efficient code. Syntax provides the structure, while semantics ensures that the code performs the intended operations."
  },
  {
    "objectID": "04_Names_and_Variables.html#sec-names",
    "href": "04_Names_and_Variables.html#sec-names",
    "title": "4  Names and Variables",
    "section": "4.1 Names",
    "text": "4.1 Names\nNames in programming are identifiers used to label and reference entities such as variables, functions, classes, and modules. They serve as a means to access stored data and functionality, making code more readable and maintainable. For instance, instead of repeatedly using a complex expression or value, we can assign it a name and refer to it using that name.\n\n4.1.1 Rules for Naming\nIn Python, there are specific rules and conventions for naming identifiers:\n\nAlphabetic Characters and Underscores: Names must begin with a letter (a-z, A-Z) or an underscore (_), followed by letters, digits (0-9), or underscores.\nCase Sensitivity: Names are case-sensitive, meaning Variable, variable, and VARIABLE are distinct identifiers.\nReserved Keywords: Names cannot be Python reserved keywords, such as if, else, for, while, class, def, etc."
  },
  {
    "objectID": "04_Names_and_Variables.html#variables",
    "href": "04_Names_and_Variables.html#variables",
    "title": "4  Names and Variables",
    "section": "4.2 Variables",
    "text": "4.2 Variables\nVariables are names assigned to data values stored in memory. They act as containers holding information that can be manipulated and accessed throughout a program. Variables allow for dynamic and flexible data handling, making it possible to perform computations, store results, and manage state.\n\nVariable Assignment\nIn Python, variable assignment is straightforward. Use the assignment operator (=) to assign a value to a variable:\nx = 10\nname = \"Alice\"\nis_student = True\n\n\nVariable Scope\nThe scope of a variable determines its accessibility within different parts of a program. There are two primary types of scope in Python:\n\nGlobal Scope: Variables defined outside any function (functions will be discussed in Chapter 8) or block have global scope and can be accessed anywhere in the program.\nLocal Scope: Variables defined within a function or block have local scope and can only be accessed within that function or block.\n\nglobal_var = \"I am global\"\n\ndef my_function():\n    local_var = \"I am local\"\n    print(global_var)  # Accessible\n    print(local_var)  # Accessible\n\nmy_function()\nprint(global_var)  # Accessible\nprint(local_var)  # Error: NameError\n\n\nConstants\nConstants are variables whose values are intended to remain unchanged throughout the program. While Python does not have built-in constant types, by convention, we use all uppercase letters to indicate constants:\nPI = 3.14159\nMAX_STUDENTS = 50\n\n\n4.2.1 Examples and Applications\nTo solidify our understanding of names and variables, let’s explore some practical examples and applications:\n\nExample: Simple Calculator\n# Simple Calculator Program\nnum1 = 10\nnum2 = 5\n\n# Performing arithmetic operations\nsum_result = num1 + num2\ndifference = num1 - num2\nproduct = num1 * num2\nquotient = num1 / num2\n\nprint(\"Sum:\", sum_result)\nprint(\"Difference:\", difference)\nprint(\"Product:\", product)\nprint(\"Quotient:\", quotient)\n\n\nExample: Temperature Conversion\n# Temperature Conversion Program (Celsius to Fahrenheit)\ncelsius = 25\nfahrenheit = (celsius * 9/5) + 32\n\nprint(celsius, \"Celsius is\", fahrenheit, \"Fahrenheit\")\nUnderstanding names and variables is crucial for effective programming. Names provide a way to reference and access data, while variables store the data we work with. By adhering to naming conventions and understanding variable scope and types, we can write clearer, more maintainable code. As we progress, these fundamental concepts will underpin more complex programming tasks and techniques."
  },
  {
    "objectID": "04_Names_and_Variables.html#exercises",
    "href": "04_Names_and_Variables.html#exercises",
    "title": "4  Names and Variables",
    "section": "4.3 Exercises",
    "text": "4.3 Exercises\n\nExercise 1: Variable Assignment\n\nAssign the value 50 to a variable named my_age and use print to display the variable.\nAssign the string \"Hello, Python!\" to a variable named greeting and use print to display the variable.\nAssign the boolean value False to a variable named is_raining and use print to display the variable.\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 2: Variable Reassignment\n\nAssign the value 10 to a variable named number and use print to display the variable.\nReassign the value of number to 20 and use print to display the variable.\nReassign the value of number to the string \"twenty\" and use print to display the variable.\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 3: Basic Arithmetic\n\nCreate two variables a and b, and assign them the values 8 and 3 respectively.\nPerform the following operations and print the results:\n\nSum of a and b\nDifference between a and b\nProduct of a and b\nQuotient of a divided by b\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 4: Temperature Conversion\n\nCreate a variable fahrenheit and assign it the value 86.\nConvert the temperature to Fahrenheit using the formula: celsius = (fahrenheit - 32) * 5/9.\nPrint the Celsius value.\n\n\n\n\n\n\n\n\n\nExercise 5: Constants\n\nDefine a constant PI with the value 3.14159.\nDefine a constant MAX_SPEED with the value 120.\nPrint both constants."
  },
  {
    "objectID": "05_Data_Types.html#common-data-types-in-python",
    "href": "05_Data_Types.html#common-data-types-in-python",
    "title": "5  Data Types",
    "section": "5.1 Common Data Types in Python",
    "text": "5.1 Common Data Types in Python\nPython supports various built-in data types, each suited for different kinds of operations and uses. The primary data types include:\n\nInteger (int)\nFloat (float)\nString (str)\nBoolean (bool)\nNoneType (None)\n\nWe will discuss each of these types in detail.\n\n5.1.1 Integer (int)\nAn integer is a whole number, positive or negative, without decimals, of unlimited length. In Python, integers are of type int.\nExample:\n\na = 10\nb = -5\nc = 123456789\n\nTo check the type of a variable, use the type() function:\n\nprint(type(a))  \nprint(type(b))\n\n&lt;class 'int'&gt;\n&lt;class 'int'&gt;\n\n\n\n\n5.1.2 Float (float)\nA float, or floating-point number, is a number that has a decimal place. Python uses the float type to represent these numbers.\nExample:\n\nx = 10.5\ny = -3.14\nz = 1.0\n\nChecking the type of a float variable:\n\nprint(type(x))\nprint(type(y))\n\n&lt;class 'float'&gt;\n&lt;class 'float'&gt;\n\n\n\n\n5.1.3 String (str)\nA string is a sequence of characters enclosed in quotes. Strings can be enclosed in single quotes ('), double quotes (\"), or triple quotes (''' or \"\"\").\nExample:\n\nname = \"Alice\"\ngreeting = 'Hello, World!'\nparagraph = \"\"\"This is a\nmultiline string.\"\"\"\n\nTo determine if a variable is a string:\n\nprint(type(name)) \n\n&lt;class 'str'&gt;\n\n\n\n\n5.1.4 Boolean (bool)\nBooleans represent one of two values: True or False. They are commonly used in conditional statements and comparisons.\nExample:\n\nis_student = True\nis_raining = False\n\nChecking the type of a boolean variable:\n\nprint(type(is_student)) \n\n&lt;class 'bool'&gt;\n\n\n\n\n5.1.5 NoneType (None)\nNone is a special data type in Python that represents the absence of a value. It is an object of its own datatype, the NoneType.\nExample:\n\nunknown = None\n\nTo check if a variable is of NoneType:\n\nprint(type(unknown))\n\n&lt;class 'NoneType'&gt;"
  },
  {
    "objectID": "05_Data_Types.html#dynamic-typing-in-python",
    "href": "05_Data_Types.html#dynamic-typing-in-python",
    "title": "5  Data Types",
    "section": "5.2 Dynamic Typing in Python",
    "text": "5.2 Dynamic Typing in Python\nPython is a dynamically typed language, which means you do not need to declare the type of a variable when you create one. The type is determined at runtime based on the value assigned to it.\nExample:\n\nvariable = 5\nprint(type(variable)) \n\nvariable = \"Hello\"\nprint(type(variable)) \n\n&lt;class 'int'&gt;\n&lt;class 'str'&gt;\n\n\nThis feature provides flexibility but requires careful handling to avoid type-related errors."
  },
  {
    "objectID": "05_Data_Types.html#type-conversion",
    "href": "05_Data_Types.html#type-conversion",
    "title": "5  Data Types",
    "section": "5.3 Type Conversion",
    "text": "5.3 Type Conversion\nSometimes, you may need to convert values from one type to another. This is known as type casting. Python provides several built-in functions for this purpose.\n\nint(): Converts a value to an integer.\nfloat(): Converts a value to a float.\nstr(): Converts a value to a string.\nbool(): Converts a value to a boolean.\n\nExample:\n\na = 10.5\nb = int(a)  # b is now 10\n\nc = \"123\"\nd = int(c)  # d is now 123\n\ne = \"True\"\nf = bool(e)  # f is now True\n\nChecking the types after conversion:\n\nprint(type(b))\nprint(type(d))\nprint(type(f))\n\n&lt;class 'int'&gt;\n&lt;class 'int'&gt;\n&lt;class 'bool'&gt;"
  },
  {
    "objectID": "05_Data_Types.html#operators-and-data-types",
    "href": "05_Data_Types.html#operators-and-data-types",
    "title": "5  Data Types",
    "section": "5.4 Operators and Data Types",
    "text": "5.4 Operators and Data Types\nOperators are used to perform operations on variables and values. Python supports various operators, and their behavior can differ based on the data types they operate on. Here, we will explore how operators work with different data types.\n\n5.4.1 Arithmetic Operators\nArithmetic operators are used to perform common mathematical operations such as addition, subtraction, multiplication, and division.\nExample with Integers:\n\na = 10\nb = 3\n\nprint(a + b) \nprint(a - b)  \nprint(a * b)  \nprint(a / b)  \nprint(a % b)  \nprint(a ** b) \nprint(a // b)  \n\n13\n7\n30\n3.3333333333333335\n1\n1000\n3\n\n\nExample with Floats:\n\nx = 10.5\ny = 3.2\n\nprint(x + y)  \nprint(x - y)  \nprint(x * y)  \nprint(x / y)\n\n13.7\n7.3\n33.6\n3.28125\n\n\n\n\n5.4.2 String Operators\nStrings can be manipulated using the + (concatenation) and * (repetition) operators.\nExample:\n\nstr1 = \"Hello\"\nstr2 = \"World\"\n\nprint(str1 + \" \" + str2)  \nprint(str1 * 3)  \n\nHello World\nHelloHelloHello\n\n\n\n\n5.4.3 Comparison Operators\nComparison operators are used to compare two values. They return a boolean value (True or False).\nExample with Integers and Floats:\n\na = 10\nb = 5\nc = 10.0\n\nprint(a == b)  \nprint(a != b)  \nprint(a &gt; b)   \nprint(a &lt; b)   \nprint(a &gt;= c)  \nprint(a &lt;= c) \n\nFalse\nTrue\nTrue\nFalse\nTrue\nTrue\n\n\nExample with Strings:\n\nstr1 = \"Hello\"\nstr2 = \"World\"\nstr3 = \"Hello\"\n\nprint(str1 == str2)  \nprint(str1 == str3)  \nprint(str1 != str2) \nprint(str1 &gt; str2)   # (Lexicographical comparison)\nprint(str1 &lt; str2)  \n\nFalse\nTrue\nTrue\nFalse\nTrue\n\n\n\n\n5.4.4 Logical Operators\nLogical operators are used to combine conditional statements.\nExample:\n\na = True\nb = False\n\nprint(a and b)  \nprint(a or b)  \nprint(not a)   \n\nFalse\nTrue\nFalse\n\n\nLogical operators can also be used with integers, where 0 is considered False and any non-zero value is considered True.\n\nx = 0\ny = 10\n\nprint(x and y)  \nprint(x or y)   \nprint(not x)  \n\n0\n10\nTrue"
  },
  {
    "objectID": "05_Data_Types.html#exercises",
    "href": "05_Data_Types.html#exercises",
    "title": "5  Data Types",
    "section": "5.5 Exercises",
    "text": "5.5 Exercises\n\nExercise 1: Identifying Data Types\nFor each of the following variables, use the type() function to determine its data type.\na = 42\nb = 3.14\nc = \"Python\"\nd = True\ne = None\n\n\nExercise 2: Type Conversion\nConvert the following values to the specified types and print the results.\n\nConvert x = 3.75 to an integer.\nConvert y = \"123\" to a float.\nConvert z = 0 to a boolean.\nConvert w = False to a string.\n\n\n\nExercise 3: Arithmetic Operations\nPerform the following arithmetic operations and print the results.\n\nAdd 15 and 23.\nSubtract 9 from 45.\nMultiply 7 by 8.\nDivide 20 by 4.\nCalculate the modulus of 27 and 4.\nRaise 2 to the power of 5.\nPerform floor division of 17 by 3.\n\n\n\nExercise 4: String Operations\nUse the appropriate operations to do the following and print the results.\n\nConcatenate the strings \"Data\" and \"Science\" with a space in between.\nRepeat the string \"Hello\" 5 times.\n\n\n\nExercise 5: Logical Operations\nEvaluate the following logical expressions and print the results.\n\nTrue and False\nTrue or False\nnot True\n(5 &gt; 3) and (2 &lt; 4)\n(10 == 10) or (5 != 5)\n\n\n\nExercise 6: Mixed-Type Operations\nDo the following operations and print the results.\n\nAdd an integer and a float: 7 + 3.14\nConcatenate a string and an integer (convert the integer to a string first): \"Age: \" + str(30)\nMultiply a string by an integer: \"Data\" * 4"
  },
  {
    "objectID": "06_Conditional_Statements.html#the-if-statement",
    "href": "06_Conditional_Statements.html#the-if-statement",
    "title": "6  Control Structures: Conditional Statements",
    "section": "6.1 The if Statement",
    "text": "6.1 The if Statement\nThe if statement is the most fundamental building block of conditional statements in Python. It allows the program to execute a block of code only if a specified condition is true. This section will delve deeper into the mechanics of the if statement, its syntax, and its practical applications.\n\nBasic Syntax\nThe basic syntax of an if statement in Python is straightforward. It consists of the keyword if followed by a condition, a colon, and an indented block of code that will be executed if the condition is true.\nSyntax:\nif condition:\n    statement(s)\n\ncondition: This is an expression that evaluates to either True or False.\nstatement(s): This is the block of code that will be executed if the condition evaluates to True.\n\nThe condition can be any expression that returns a Boolean value (i.e., True or False). If the condition evaluates to True, the indented block of code following the if statement is executed. If the condition evaluates to False, the block of code is skipped.\nExample:\n\nx = 10\nif x &gt; 5:\n    print(\"x is greater than 5\")\n\nx is greater than 5\n\n\nIn this example, the condition x &gt; 5 evaluates to True because 10 is greater than 5. Therefore, the code within the if block is executed, resulting in the output “x is greater than 5”.\n\n\nUsing Comparison Operators\nThe condition in an if statement often involves comparison operators. These operators compare two values and return True or False based on the comparison.\nCommon Comparison Operators:\n\n==: Equal to\n!=: Not equal to\n&gt;: Greater than\n&lt;: Less than\n&gt;=: Greater than or equal to\n&lt;=: Less than or equal to\n\nExamples:\n\n# Equal to\nx = 5\nif x == 5:\n    print(\"x is equal to 5\")\n\nx is equal to 5\n\n\n\n# Not equal to\ny = 10\nif y != 5:\n    print(\"y is not equal to 5\")\n\ny is not equal to 5\n\n\n\n# Greater than\na = 7\nif a &gt; 3:\n    print(\"a is greater than 3\")\n\na is greater than 3\n\n\n\n# Less than\nb = 2\nif b &lt; 5:\n    print(\"b is less than 5\")\n\nb is less than 5\n\n\n\n# Greater than or equal to\nc = 8\nif c &gt;= 8:\n    print(\"c is greater than or equal to 8\")\n\nc is greater than or equal to 8\n\n\n\n# Less than or equal to\nd = 4\nif d &lt;= 4:\n    print(\"d is less than or equal to 4\")\n\nd is less than or equal to 4\n\n\n\n\nCombining Conditions with Logical Operators\nSometimes, you need to check multiple conditions simultaneously. Python provides logical operators to combine multiple conditions.\nLogical Operators:\n\nand: Returns True if both conditions are True\nor: Returns True if at least one condition is True\nnot: Returns True if the condition is False\n\nExamples:\n\n# Using 'and' operator\nx = 10\ny = 20\nif x &gt; 5 and y &gt; 15:\n    print(\"Both conditions are true\")\n\nBoth conditions are true\n\n\n\n# Using 'or' operator\na = 5\nb = 10\nif a &gt; 7 or b &gt; 7:\n    print(\"At least one condition is true\")\n\nAt least one condition is true\n\n\n\n# Using 'not' operator\nc = 3\nif not c &gt; 5:\n    print(\"c is not greater than 5\")\n\nc is not greater than 5\n\n\nIn the first example, the condition x &gt; 5 and y &gt; 15 evaluates to True because both 10 &gt; 5 and 20 &gt; 15 are true. Therefore, the code within the if block is executed, resulting in the output “Both conditions are true”.\nIn the second example, the condition a &gt; 7 or b &gt; 7 evaluates to True because 10 &gt; 7 is true even though 5 &gt; 7 is false. Hence, the output is “At least one condition is true”.\nIn the third example, the condition not c &gt; 5 evaluates to True because c &gt; 5 is false, and not operator negates it. Therefore, the output is “c is not greater than 5”.\n\n\nNested if Statements\nYou can nest if statements within other if statements to create more complex decision structures. This means placing one if statement inside another if statement’s block of code.\nExample:\n\nx = 15\nif x &gt; 10:\n    print(\"x is greater than 10\")\n    if x &gt; 20:\n        print(\"x is also greater than 20\")\n\nx is greater than 10\n\n\nIn this example, the outer if statement checks if x is greater than 10. Since x is 15, the condition is true, and the code within the block is executed. Inside this block, there is another if statement that checks if x is greater than 20. Since 15 is not greater than 20, the block of the nested if statement is not executed."
  },
  {
    "objectID": "06_Conditional_Statements.html#the-else-clause",
    "href": "06_Conditional_Statements.html#the-else-clause",
    "title": "6  Control Structures: Conditional Statements",
    "section": "6.2 The else Clause",
    "text": "6.2 The else Clause\nThe else clause in Python provides an alternative block of code that will execute if the condition in the if statement evaluates to False. This allows for a two-way decision-making process: if the condition is true, one set of statements will run, otherwise, a different set of statements will run.\n\nBasic Syntax\nThe basic syntax for using the else clause follows directly after an if statement. The else clause must be at the same indentation level as the if statement, and its block of code must be indented further.\nSyntax:\nif condition:\n    statement(s)\nelse:\n    statement(s)\n\ncondition: This is an expression that evaluates to either True or False.\nstatement(s): This is the block of code that will be executed if the condition evaluates to False.\n\nExample:\n\nx = 3\nif x &gt; 5:\n    print(\"x is greater than 5\")\nelse:\n    print(\"x is not greater than 5\")\n\nx is not greater than 5\n\n\nIn this example, the condition x &gt; 5 evaluates to False because 3 is not greater than 5. Therefore, the code within the else block is executed, resulting in the output “x is not greater than 5”.\n\n\nNested else Clauses\nelse clauses can be nested within other conditional blocks to create more complex decision structures. This is useful when the logic requires multiple levels of checks.\nExample:\n\nx = 15\nif x &gt; 10:\n    print(\"x is greater than 10\")\n    if x &gt; 20:\n        print(\"x is also greater than 20\")\n    else:\n        print(\"x is between 11 and 20\")\nelse:\n    print(\"x is 10 or less\")\n\nx is greater than 10\nx is between 11 and 20\n\n\nIn this example, the outer if statement checks if x is greater than 10. Since x is 15, the condition is true, and the code within the block is executed. Inside this block, there is another if statement that checks if x is greater than 20. Since 15 is not greater than 20, the else block of the nested if statement is executed, resulting in the output “x is between 11 and 20”."
  },
  {
    "objectID": "06_Conditional_Statements.html#the-elif-clause",
    "href": "06_Conditional_Statements.html#the-elif-clause",
    "title": "6  Control Structures: Conditional Statements",
    "section": "6.3 The elif Clause",
    "text": "6.3 The elif Clause\nIn Python, the elif clause (short for “else if”) is used to check multiple conditions in a sequence. It allows you to add more than one conditional expression to an if statement, creating a chain of conditions that are evaluated in order. When one of these conditions evaluates to True, the corresponding block of code is executed, and the rest of the conditions are skipped.\n\nBasic Syntax\nThe elif clause follows the if clause and is used to test additional conditions if the previous conditions were not true. You can have as many elif clauses as you need, and an optional else clause can be included at the end to handle cases where none of the if or elif conditions are true.\nSyntax:\nif condition1:\n    statement(s)\nelif condition2:\n    statement(s)\nelif condition3:\n    statement(s)\n\ncondition1, condition2, condition3: These are expressions that evaluate to either True or False.\nstatement(s): These are the blocks of code that will be executed if the corresponding condition evaluates to True.\n\n\n\nUsing Multiple elif Clauses\nThe elif clause allows you to handle multiple potential cases in a clear and concise manner. The conditions are evaluated from top to bottom, and as soon as a True condition is found, the corresponding block of code is executed, and the rest of the conditions are skipped.\nExample:\n\nscore = 85\n\nif score &gt;= 90:\n    print(\"Grade: A\")\nelif score &gt;= 80:\n    print(\"Grade: B\")\nelif score &gt;= 70:\n    print(\"Grade: C\")\nelif score &gt;= 60:\n    print(\"Grade: D\")\nelif score &lt; 60:\n    print(\"Grade: F\")\n\nGrade: B\n\n\nIn this example, the program checks the score and assigns a grade based on predefined ranges. The conditions are evaluated in order: score &gt;= 90 is False, score &gt;= 80 is True, so the code within the elif score &gt;= 80 block is executed, resulting in the output “Grade: B”.\n\n\nCombining elif with else\nThe else clause is optional but often used at the end of an if-elif chain to catch any cases that do not meet the previous conditions. This ensures that there is always a defined action for any possible input.\nExample:\n\ntemperature = 75\n\nif temperature &gt; 85:\n    print(\"It's hot outside.\")\nelif temperature &gt; 65:\n    print(\"The weather is nice.\")\nelse:\n    print(\"It's cold outside.\")\n\nThe weather is nice.\n\n\nIn this example, the temperature is checked against three conditions. If the temperature is greater than 85, it prints “It’s hot outside.” If not, it checks if the temperature is greater than 65, printing “The weather is nice.” If neither condition is true, it defaults to printing “It’s cold outside.”\n\n\nPractical Applications\nExample: Speed Limit Checker\nLet’s create a program that checks a car’s speed and prints a message based on the speed.\n\nspeed = 55\n\nif speed &gt; 80:\n    print(\"You are speeding excessively.\")\nelif speed &gt; 60:\n    print(\"You are speeding.\")\nelif speed &gt; 40:\n    print(\"You are driving at a safe speed.\")\nelse:\n    print(\"You are driving below the speed limit.\")\n\nYou are driving at a safe speed.\n\n\nIn this program, the speed is checked against multiple conditions to provide feedback on the driving speed. The conditions are evaluated in sequence, and the appropriate message is printed based on the speed.\n\n\nNested elif Clauses\nSometimes, you may need to nest elif clauses within other if-elif-else blocks to handle more complex decision-making processes.\nExample: Admission Criteria\nLet’s create a program that checks admission criteria based on age and test scores.\n\nage = 18\ntest_score = 85\n\nif age &gt;= 18:\n    if test_score &gt;= 90:\n        print(\"Admitted with a scholarship.\")\n    elif test_score &gt;= 75:\n        print(\"Admitted.\")\n    else:\n        print(\"Not admitted due to low test score.\")\nelse:\n    print(\"Not admitted due to age requirement.\")\n\nAdmitted.\n\n\nIn this example, the outer if statement checks if the age is 18 or older. If true, it enters a nested if-elif-else block that checks the test score. Depending on the test score, it prints the appropriate admission status. If the age condition is not met, it prints “Not admitted due to age requirement.”\nThe elif clause in Python is a powerful tool for handling multiple conditions in a clear and structured manner. By combining if, elif, and else clauses, you can create flexible decision-making processes in your programs. This allows your code to react dynamically to a wide range of inputs and conditions, making it more robust and versatile."
  },
  {
    "objectID": "06_Conditional_Statements.html#conditional-expressions",
    "href": "06_Conditional_Statements.html#conditional-expressions",
    "title": "6  Control Structures: Conditional Statements",
    "section": "6.4 Conditional Expressions",
    "text": "6.4 Conditional Expressions\nPython also supports conditional expressions, which are a more concise way to write simple if-else statements.\nSyntax:\nvalue_if_true if condition else value_if_false\nExample:\n\nx = 5\nresult = \"Positive\" if x &gt; 0 else \"Non-positive\"\nprint(result)\n\nPositive\n\n\nThis example assigns the value “Positive” to the variable result if the condition x &gt; 0 is True, otherwise it assigns “Non-positive”. The output will be “Positive”."
  },
  {
    "objectID": "06_Conditional_Statements.html#exercises",
    "href": "06_Conditional_Statements.html#exercises",
    "title": "6  Control Structures: Conditional Statements",
    "section": "6.5 Exercises",
    "text": "6.5 Exercises\n\nExercise 1: Odd or Even\nWrite a program that checks if a number is odd or even using conditionals.\n\n\n\n\n\n\n\n\n\nExercise 2: Age Group\nWrite a program that categorizes a person’s age group using only if and else statements.\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 3: Positive, Negative, or Zero\nWrite a program that checks if a number is positive, negative, or zero. You must use at least one elif and one else statements."
  },
  {
    "objectID": "07_Loops.html#the-while-loop",
    "href": "07_Loops.html#the-while-loop",
    "title": "7  Control Structures: Loops",
    "section": "7.1 The while Loop",
    "text": "7.1 The while Loop\nThe while loop is one of the fundamental control structures in Python, allowing the repeated execution of a block of code as long as a specified condition is True. This type of loop is particularly useful when the number of iterations is not known beforehand and depends on dynamic conditions during runtime.\n\nBasic Syntax\nThe basic syntax of a while loop is:\nwhile condition:\n    statement(s)\n\ncondition: An expression that evaluates to True or False.\nstatement(s): The block of code that will be executed repeatedly as long as the condition is True.\n\n\n\nExample: Simple while Loop\nConsider a simple example where we print numbers from 1 to 5:\n\ni = 1\nwhile i &lt;= 5:\n    print(i)\n    i += 1\n\n1\n2\n3\n4\n5\n\n\nIn this example, the variable i is initialized to 1. The while loop checks if i is less than or equal to 5. If the condition is True, it prints the value of i and increments i by 1. The loop continues until i becomes greater than 5.\n\n\nInfinite Loops\nA common pitfall with while loops is the creation of infinite loops, which occur when the loop’s condition never becomes False. This can cause the program to run indefinitely, potentially causing it to become unresponsive.\nExample of an infinite loop:\nwhile True:\n    print(\"This loop will run forever.\")\nTo prevent infinite loops, ensure that the loop’s condition will eventually become False.\n\n\nwhile Loop with Else Clause\nPython allows an optional else clause with while loops. The else block is executed when the loop condition becomes False.\nExample:\n\ni = 1\nwhile i &lt;= 5:\n    print(i)\n    i += 1\nelse:\n    print(\"Loop ended naturally.\")\n\n1\n2\n3\n4\n5\nLoop ended naturally.\n\n\nIn this example, the else block is executed after the while loop finishes executing, printing “Loop ended naturally.”\n\n\nNested while Loops\nwhile loops can be nested within other loops to handle more complex tasks, such as iterating over multi-dimensional data structures.\nExample:\ni = 1\nwhile i &lt;= 3:\n    j = 1\n    while j &lt;= 3:\n        print(j)\n        j += 1\n    i += 1\nIn this example, the outer while loop iterates over the variable i from 1 to 3, and for each iteration, the inner while loop iterates over the variable j from 1 to 3.\n\n\nControlling Loop Execution\nPython provides several statements to control the execution of while loops:\n\nbreak: Terminates the loop prematurely.\ncontinue: Skips the rest of the loop body for the current iteration and proceeds to the next iteration.\npass: Does nothing and is used as a placeholder in loops or functions where code will be added later.\n\nExamples:\n\nUsing break:\n\ni = 1\nwhile i &lt;= 10:\n    if i == 5:\n        break\n    print(i)\n    i += 1\n\n1\n2\n3\n4\n\n\nUsing continue:\n\ni = 1\nwhile i &lt;= 10:\n    if i % 2 == 0:\n        i += 1\n        continue\n    print(i)\n    i += 1\n\n1\n3\n5\n7\n9\n\n\nUsing pass:\n\ni = 1\nwhile i &lt;= 10:\n    if i % 2 == 0:\n        pass  # Placeholder for future code\n    else:\n        print(i)\n    i += 1\n\n1\n3\n5\n7\n9"
  },
  {
    "objectID": "07_Loops.html#the-for-loop",
    "href": "07_Loops.html#the-for-loop",
    "title": "7  Control Structures: Loops",
    "section": "7.2 The for Loop",
    "text": "7.2 The for Loop\nThe for loop in Python is used for iterating over a sequence. Unlike the while loop, the for loop is preferred for its simplicity and readability when working with sequences. It provides a straightforward way to traverse elements in a collection, making it easier to write and understand.\n\nBasic Syntax\nThe basic syntax of a for loop is:\nfor variable in sequence:\n    statement(s)\n\nvariable: A variable that takes the value of each item in the sequence during iteration.\nsequence: A collection of items to iterate over (e.g., list, tuple, string, range).\nstatement(s): The block of code that will be executed for each item in the sequence.\n\n\n\nExample: Iterating Over a List\nConsider an example where we iterate over a list of numbers and print each number:\n\nnumbers = [1, 2, 3, 4, 5]\nfor num in numbers:\n    print(num)\n\n1\n2\n3\n4\n5\n\n\nIn this example, the for loop iterates over the list numbers, and the variable num takes the value of each item in the list during each iteration.\n\n\nThe range() Function\nThe range() function generates a sequence of numbers, which is particularly useful for creating loops that run a specific number of times. The range() function can take up to three arguments: start, stop, and step.\n\nstart: The starting value of the sequence (inclusive). Default is 0.\nstop: The ending value of the sequence (exclusive).\nstep: The difference between each pair of consecutive values. Default is 1.\n\nExample using range():\n\nfor i in range(1, 6):\n    print(i)\n\n1\n2\n3\n4\n5\n\n\nThis loop prints numbers from 1 to 5. The range(1, 6) function generates the numbers 1, 2, 3, 4, and 5.\n\n\nIterating Over Strings\nStrings are sequences of characters, and you can use a for loop to iterate over each character in a string.\nExample:\n\nmessage = \"Hello, World!\"\nfor char in message:\n    print(char)\n\nH\ne\nl\nl\no\n,\n \nW\no\nr\nl\nd\n!\n\n\nIn this example, the for loop iterates over the string message, and the variable char takes the value of each character in the string during each iteration.\n\n\nLoop Control Statements\nAs with while loops, Python provides several statements to control the execution of for loops:\n\nbreak: Terminates the loop prematurely.\ncontinue: Skips the rest of the code inside the loop for the current iteration and moves to the next iteration.\npass: Does nothing and is used as a placeholder in loops or functions where code will be added later.\n\nExamples:\n\nUsing break:\n\nfor i in range(1, 10):\n    if i == 5:\n        break\n    print(i)\n\n1\n2\n3\n4\n\n\nUsing continue:\n\nfor i in range(1, 10):\n    if i % 2 == 0:\n        continue\n    print(i)\n\n1\n3\n5\n7\n9\n\n\nUsing pass:\n\nfor i in range(1, 10):\n    if i % 2 == 0:\n        pass  # Placeholder for future code\n    else:\n        print(i)\n\n1\n3\n5\n7\n9\n\n\n\n\n\nPractical Applications\nfor loops are used in a wide range of practical applications, from data processing to generating patterns. Here are some examples:\nExample: Summing Numbers in a List\nCalculate the sum of all numbers in a list:\n\nnumbers = [23, 45, 12, 89, 34]\ntotal = 0\n\nfor num in numbers:\n    total += num\n\nprint(\"Sum:\", total)\n\nSum: 203\n\n\nIn this example, the for loop iterates over the list numbers, adding each number to the variable total, which holds the sum.\nExample: Finding the Maximum Value\nFind the maximum value in a list:\n\nnumbers = [23, 45, 12, 89, 34]\nmax_value = numbers[0]\n\nfor num in numbers:\n    if num &gt; max_value:\n        max_value = num\n\nprint(\"Maximum value:\", max_value)\n\nMaximum value: 89\n\n\nIn this example, the for loop iterates over the list numbers, updating the variable max_value if a larger number is found."
  },
  {
    "objectID": "07_Loops.html#exercises",
    "href": "07_Loops.html#exercises",
    "title": "7  Control Structures: Loops",
    "section": "7.3 Exercises",
    "text": "7.3 Exercises\n\nExercise 1: Counting Down\nWrite a program that counts down from 10 to 1 using a while loop.\n\n\n\n\n\n\n\n\n\n\nExercise 2: Sum of Positive Numbers\nWrite a program that repeatedly asks the user for a number until they enter a negative number. The program should then print the sum of all positive numbers entered.\n\n\n\n\n\n\ninput()\n\n\n\nThe input() function is used to display the given string to the console and wait for user input. The value entered by the user will be a string. Thus, the input must be converted to an int if an integer is needed in the rest of the code.\nFor this exercise, you can get the user input with the command\nnum = int(input(\"Enter a number (negative number to stop): \"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 3: Factorial Calculation\nWrite a program to calculate the factorial of a number using a while loop. Print the end result. Use an input() function as in Exercise 2.\n\n\n\n\n\n\n\n\n\n\n\nExercise 4: Guess the Number\nWrite a number guessing game where the program generates a random number between 1 and 100, and the user has to guess it. The program should give hints if the guess is too high or too low and keep asking until the user guesses correctly.\nUse the following code to generate the random number:\nimport random\nnumber = random.randint(1, 100)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 5: Sum of Even Numbers\nWrite a program to calculate the sum of all even numbers between 1 and 50.\n\n\n\n\n\n\n\n\n\nExercise 6: Prime Numbers\nWrite a program to print all prime numbers between 1 and 50 using a for loop and conditional statements."
  },
  {
    "objectID": "08_Functions.html#defining-a-function",
    "href": "08_Functions.html#defining-a-function",
    "title": "8  Functions",
    "section": "8.1 Defining a Function",
    "text": "8.1 Defining a Function\nTo define a function in Python, you use the def keyword, followed by the function name, parentheses (), and a colon :. The function body, which contains the code to be executed, is indented beneath the function definition.\nSyntax:\ndef function_name(parameters):\n    # Function body\n    statement(s)\nExample:\n\ndef greet():\n    print(\"Hello, World!\")\n\nIn this example, the function greet() is defined to print the message “Hello, World!” when called."
  },
  {
    "objectID": "08_Functions.html#calling-a-function",
    "href": "08_Functions.html#calling-a-function",
    "title": "8  Functions",
    "section": "8.2 Calling a Function",
    "text": "8.2 Calling a Function\nOnce a function is defined, it can be called by using its name followed by parentheses ().\nExample:\n\ngreet() \n\nHello, World!\n\n\nHere, the greet() function is invoked, and the message is displayed."
  },
  {
    "objectID": "08_Functions.html#function-arguments",
    "href": "08_Functions.html#function-arguments",
    "title": "8  Functions",
    "section": "8.3 Function Arguments",
    "text": "8.3 Function Arguments\nFunctions can accept input values called arguments or parameters, allowing them to perform operations based on the input provided. These arguments are specified within the parentheses when defining the function.\n\n8.3.1 Positional Arguments\nPositional arguments are the most straightforward type of arguments. They are assigned to parameters based on their position in the function call.\nExample:\n\ndef greet(name):\n    print(f\"Hello, {name}!\")\n\ngreet(\"Alice\")\n\nHello, Alice!\n\n\n\n\n\n\n\n\nf-strings\n\n\n\nThe argument in the print() function above is called an f-string. An f-string, introduced in Python 3.6, is a way to embed expressions inside string literals using curly braces {}. The f or F before the opening quote of the string indicates that it is an f-string. This allows you to include variables or expressions directly within the string, making string formatting more concise and readable.\n\n\nPositional arguments are assigned to function parameters by their order of appearance. This means the first argument in the function call is passed to the first parameter, the second argument to the second parameter, and so on.\nExample: Consider the following function definition:\n\ndef describe_person(name, age, city):\n    print(f\"{name} is {age} years old and lives in {city}.\")\n\nIf you call this function with the following positional arguments:\ndescribe_person(\"Alice\", 30, \"New York\")\nThe function execution will map the arguments as follows:\n\nname will be assigned the value \"Alice\"\nage will be assigned the value 30\ncity will be assigned the value \"New York\"\n\nThe output will be:\nAlice is 30 years old and lives in New York.\n\nImportance of Order\nSince positional arguments rely on the order in which they are passed, swapping the order can lead to incorrect or unintended results.\nExample of Incorrect Order:\ndescribe_person(30, \"Alice\", \"New York\")\nIn this case:\n\nname will be assigned 30\nage will be assigned \"Alice\"\ncity will be assigned \"New York\"\n\nThis will produce the incorrect output:\n30 is Alice years old and lives in New York.\n\n\n\n8.3.2 Keyword Arguments\nKeyword arguments allow you to specify the values for parameters by explicitly naming them in the function call, regardless of their order.\nExample:\n\ndef greet(name, message):\n    print(f\"{message}, {name}!\")\n\ngreet(name=\"Bob\", message=\"Good morning\") \n\nGood morning, Bob!\n\n\nThe function can also be called with the order swapped but with the correct names.\n\ngreet(message=\"Good morning\", name=\"Bob\") \n\nGood morning, Bob!\n\n\nHere, the arguments are passed by specifying the parameter names, providing flexibility in the order of arguments.\n\nCombining Positional and Keyword Arguments\nPositional arguments can be combined with keyword arguments. However, when mixing them, positional arguments must always come before keyword arguments.\nExample:\n\ndescribe_person(\"Alice\", age=30, city=\"New York\")\n\nAlice is 30 years old and lives in New York.\n\n\nThis call is valid and will produce the correct output, as the positional argument \"Alice\" is followed by keyword arguments for age and city.\n\n\n\n8.3.3 Default Arguments\nDefault arguments allow you to define a function with default values for certain parameters. If no argument is provided for a parameter with a default value, the default is used.\nExample:\n\ndef greet(name, message=\"Hello\"):\n    print(f\"{message}, {name}!\")\n\ngreet(\"Charlie\")  \ngreet(\"Charlie\", \"Goodbye\") \n\nHello, Charlie!\nGoodbye, Charlie!\n\n\nIn this example, the message parameter has a default value of \"Hello\", which is used when no other value is provided.\n\n\n8.3.4 Variable-Length Arguments\nIn Python, functions are not limited to accepting a fixed number of arguments. You can design functions to accept a variable number of arguments, allowing for greater flexibility and adaptability in different scenarios. Python provides two special types of arguments for this purpose: *args for positional arguments and **kwargs for keyword arguments. We will discuss *args here and come back to **kwargs later in Chapter 11 after we discuss dictionaries.\n\n*args – Variable-Length Positional Arguments\nThe *args syntax allows a function to accept any number of positional arguments. When you use *args in a function definition, Python collects all the positional arguments passed into the function and stores them in a tuple, which is an ordered and immutable collection of items (discussed in Chapter 10). When you define a function with *args, it can handle calls with any number of positional arguments—from zero to many.\nExample:\n\ndef greet(*names):\n    for name in names:\n        print(f\"Hello, {name}!\")\n\nHere’s how this function works:\n\nIf you call greet(\"Alice\", \"Bob\", \"Charlie\"), the function will receive names as a tuple containing (\"Alice\", \"Bob\", \"Charlie\").\nThe function will then iterate over the tuple and print a greeting for each name.\n\n\ngreet(\"Alice\", \"Bob\", \"Charlie\")\n\nHello, Alice!\nHello, Bob!\nHello, Charlie!\n\n\n\nWhen to Use *args\n\nWhen the number of inputs is unknown: If you’re writing a function that might need to handle a varying number of inputs, *args is ideal.\nFor flexible APIs: In some cases, you want to provide a flexible API that allows users to pass in any number of arguments without enforcing a strict parameter count.\n\nExample: Imagine a function that calculates the total sum of an arbitrary number of numbers:\n\ndef calculate_sum(*numbers):\n    total = 0\n    for number in numbers:\n        total += number\n    return total\n\nprint(calculate_sum(1, 2, 3)) \nprint(calculate_sum(5, 10, 15, 20))\n\n6\n50\n\n\nThis function can sum any number of integers or floats, demonstrating how *args enables flexible input handling."
  },
  {
    "objectID": "08_Functions.html#return-values",
    "href": "08_Functions.html#return-values",
    "title": "8  Functions",
    "section": "8.4 Return Values",
    "text": "8.4 Return Values\nFunctions can return values using the return statement. The value returned can be assigned to a variable for further use in the program.\nExample:\n\ndef add(a, b):\n    return a + b\n\nresult = add(3, 4)\nprint(result) \n\n7\n\n\nHere, the add function returns the sum of a and b, which is then stored in the variable result.\n\n8.4.1 Returning Multiple Values\nIn Python, a function can return more than one value at a time, which is a feature that adds considerable flexibility to the way functions are used. When a function returns multiple values, it does so by returning a tuple. This allows you to return several related pieces of data from a single function call, without the need to explicitly create and manage a complex data structure.\n\nHow Multiple Return Values Work\nWhen a function is designed to return multiple values, it simply lists the values after the return keyword, separated by commas. Python automatically packages these values into a tuple. The caller of the function can then unpack this tuple (see Chapter 10) into separate variables, each receiving one of the returned values.\nExample:\nConsider the following example:\n\ndef add_subtract(a, b):\n    return a + b, a - b\n\nIn this function:\n\na + b computes the sum of the two arguments a and b.\na - b computes the difference between a and b.\nBoth values are returned together as a tuple.\n\nWhen this function is called:\n\nsum_result, diff_result = add_subtract(10, 5)\nprint(sum_result)  \nprint(diff_result)  \n\n15\n5\n\n\nHere, the tuple (15, 5) is returned, and it is immediately unpacked into the variables sum_result and diff_result. This allows the caller to easily access each result separately.\n\n\nBenefits of Returning Multiple Values\nReturning multiple values from a function is particularly advantageous in situations where a single calculation or process naturally produces more than one result.\nExample 1: Mathematical Operations\n\ndef calculate_area_perimeter(length, width):\n    area = length * width\n    perimeter = 2 * (length + width)\n    return area, perimeter\n\narea, perimeter = calculate_area_perimeter(5, 3)\nprint(f\"Area: {area}, Perimeter: {perimeter}\")\n\nArea: 15, Perimeter: 16\n\n\nIn this example, the function calculate_area_perimeter returns both the area and perimeter of a rectangle. This allows the caller to retrieve and use both pieces of information with a single function call.\nExample 2: Finding Extremes\n\ndef find_extremes(numbers):\n    return max(numbers), min(numbers)\n\nmaximum, minimum = find_extremes([10, 20, 5, 30, 15])\nprint(f\"Maximum: {maximum}, Minimum: {minimum}\")\n\nMaximum: 30, Minimum: 5\n\n\nHere, the function find_extremes computes and returns both the maximum and minimum values from a list of numbers, making it easy to handle both results simultaneously.\n\n\nUnpacking Returned Values\nWhen a function returns multiple values, the caller can unpack these values into individual variables. This is done by assigning the function call to a tuple of variables corresponding to the number of values returned.\nExample:\n\nsum_result, diff_result = add_subtract(10, 5)\n\nIn this case, the returned tuple (15, 5) is unpacked into sum_result and diff_result, making the individual results accessible immediately.\n\n\nSingle Return Value with a Tuple\nIf needed, the function can return a tuple directly without unpacking it in the calling code. This can be useful when the function’s result is intended to be passed around or used as a single entity.\nExample:\n\nresult = add_subtract(10, 5)\nprint(result) \n\n(15, 5)\n\n\nHere, the entire tuple (15, 5) is returned as a single object and can be used as such."
  },
  {
    "objectID": "08_Functions.html#best-practices-in-function-design",
    "href": "08_Functions.html#best-practices-in-function-design",
    "title": "8  Functions",
    "section": "8.5 Best Practices in Function Design",
    "text": "8.5 Best Practices in Function Design\nDesigning functions effectively is crucial for writing clean, maintainable, and efficient code. Well-designed functions not only make your code easier to understand and use but also reduce the likelihood of bugs and make it easier to extend and modify your programs. Below are some best practices to follow when designing functions in Python.\n\nUse Descriptive Names\nA function’s name should clearly and concisely describe what the function does. Descriptive names make the code more readable and self-documenting, allowing others (and your future self) to understand the purpose of the function without needing extensive comments or external documentation.\nExample:\n\ndef calculate_average(scores):\n    return sum(scores) / len(scores)\n\nIn this example, the function name calculate_average clearly indicates that the function computes the average of a list of scores. Anyone reading the code can immediately grasp the function’s purpose without needing to examine its implementation.\nWhy This Matters:\n\nReadability: Descriptive names make your code easier to read and understand.\nMaintainability: When functions are clearly named, it’s easier to locate and update the appropriate function when changes are needed.\nCollaboration: In team settings, clear function names help other developers understand and use your code correctly, reducing the potential for errors.\n\n\n\nKeep Functions Focused\nA well-designed function should perform a single, clearly defined task or a set of closely related tasks. This practice, often referred to as the “Single Responsibility Principle,” ensures that your functions are simple, modular, and reusable.\nExample:\ndef read_file(file_path):\n    # Processing logic here\n    pass\n\ndef process_data(data):\n    # Processing logic here\n    pass\n\ndef write_file(file_path, data):\n    # Processing logic here\n    pass\n\n\n\n\n\n\npass\n\n\n\nIn Python, the pass keyword is used as a placeholder in your code. It allows you to write syntactically correct code blocks where no action is required. Essentially, pass does nothing when executed. It’s particularly useful in situations where you have a code structure that requires a statement, but you haven’t decided what the specific code should be yet.\nThink of pass as a placeholder in your code that let you outline the structure of your program without having to fill in the details immediately. This can be very helpful during the initial stages of writing or when planning out complex code.\n\n\nIn this example, each function is focused on a specific task: reading a file, processing data, and writing to a file. By keeping each function focused, the code becomes more modular and easier to maintain.\nWhy This Matters:\n\nSimplicity: Functions that do one thing are easier to understand, test, and debug.\nReusability: Focused functions are more likely to be reusable in different parts of your program or even in other projects.\nMaintainability: When functions are responsible for a single task, changes to one part of the code are less likely to have unintended side effects on other parts.\n\n\n\nAvoid Side Effects\nSide effects occur when a function modifies some state or interacts with outside elements like global variables, files, or databases, which are not directly related to its inputs and outputs. While side effects are sometimes necessary, minimizing them helps ensure that functions are predictable and easier to test.\nRecall that global and local variables were first discussed in Section 4.1.\nExample of a Function with Side Effects:\n\ntotal = 0\n\ndef add_to_total(amount):\n    global total\n    total += amount\n\nIn this example, the function add_to_total modifies the global variable total, which is a side effect. This can lead to unpredictable behavior, especially in larger programs where the global state is modified by multiple functions.\nBetter Approach:\n\ndef calculate_new_total(current_total, amount):\n    return current_total + amount\n\nIn this revised example, the function calculate_new_total returns a new total based on the inputs without modifying any external state. The function is now pure, meaning its output depends only on its inputs and has no side effects.\nWhy This Matters:\n\nPredictability: Functions without side effects are easier to reason about because they produce the same output for the same input every time.\nTestability: Pure functions are easier to test since you don’t need to set up or tear down any external state.\nDebugging: Functions that don’t cause side effects are less likely to introduce hidden bugs related to state changes elsewhere in the program.\n\n\n\nDocument Your Functions\nEven with descriptive names, adding docstrings to your functions is a good practice. A docstring provides a description of the function’s purpose, parameters, and return values, making it easier for others to use your function correctly.\nExample:\ndef calculate_average(scores):\n    \"\"\"\n    Calculates the average of a list of scores.\n\n    Parameters:\n    scores (list of int/float): A list of numeric scores.\n\n    Returns:\n    float: The average of the scores.\n    \"\"\"\n    return sum(scores) / len(scores)\nWhy This Matters:\n\nClarity: Docstrings clarify how to use the function, what inputs it expects, and what outputs it provides.\nCollaboration: Docstrings make it easier for others to understand and use your code.\nSelf-Documentation: Well-documented functions serve as a form of in-code documentation, reducing the need for external documentation.\n\nBy following these best practices in function design—using descriptive names, keeping functions focused, avoiding side effects, and documenting your functions—you can create Python code that is easier to read, maintain, and extend. These practices not only improve the quality of your code but also make it more robust and reliable, facilitating collaboration and reducing the likelihood of bugs."
  },
  {
    "objectID": "08_Functions.html#exercises",
    "href": "08_Functions.html#exercises",
    "title": "8  Functions",
    "section": "8.6 Exercises",
    "text": "8.6 Exercises\n\nExercise 1: Simple Greeting Function\nWrite a function greet_user that takes a user’s name as input and prints a greeting message.\n\n\nExercise 2: Arithmetic Function\nWrite a function calculate that takes two numbers and returns their sum, difference, product, and quotient.\n\n\nExercise 3: Temperature Conversion\nWrite a function convert_temperature that converts a temperature from Celsius to Fahrenheit.\n\n\nExercise 4: Flexible Function\nWrite a function summarize that can take any number of numerical arguments and returns their sum and average."
  },
  {
    "objectID": "09_Libraries.html#understanding-modules",
    "href": "09_Libraries.html#understanding-modules",
    "title": "9  Introduction to Modules and Libraries",
    "section": "9.1 Understanding Modules",
    "text": "9.1 Understanding Modules\nModules allow you to break your code into separate files, making it easier to manage and understand. A module can contain functions, classes, variables, and runnable code. By organizing your code into modules, you can create reusable components that can be easily imported into other projects.\nExample: Creating a Simple Module\nLet’s start by creating a simple module. Suppose we have a file named greetings.py:\n\n# greetings.py\n\ndef say_hello(name):\n    \"\"\"Print a friendly greeting.\"\"\"\n    return f\"Hello, {name}!\"\n\ndef say_goodbye(name):\n    \"\"\"Print a farewell message.\"\"\"\n    return f\"Goodbye, {name}!\"\n\nThis module contains two functions: say_hello and say_goodbye. You can import this module into another script and use these functions.\nExample: Using the Module\n# main.py\n\nimport greetings\n\nprint(greetings.say_hello(\"Alice\"))\nprint(greetings.say_goodbye(\"Alice\"))\nRunning main.py would output:\nHello, Alice!\nGoodbye, Alice!\n\n\n\n\n\n\nNote\n\n\n\nThe .py file that you are importing as a module needs to be in the same directory as the file you are importing the module into. In the example above, greetings.py and main.py needs to be in the same directory.\n\n\nHere, the greetings module is imported, and its functions are called to print personalized messages. This simple example demonstrates the power of modules in keeping your code organized and reusable."
  },
  {
    "objectID": "09_Libraries.html#importing-modules",
    "href": "09_Libraries.html#importing-modules",
    "title": "9  Introduction to Modules and Libraries",
    "section": "9.2 Importing Modules",
    "text": "9.2 Importing Modules\nModules are imported to gain access to their functions, classes, and variables. Python provides several methods for importing modules, each offering different levels of control and flexibility depending on your use case. Let’s explore these methods in detail.\n\nStandard Import\nThe most common way to import a module is by using a standard import statement. This method imports the entire module, making all of its contents accessible. However, to use any function or class from the module, you must prefix it with the module’s name. This ensures that there are no conflicts between functions or variables from different modules, as everything is neatly contained within its namespace.\nExample: Using math Module\n\nimport math\n\n# Accessing the square root function from the math module\nresult = math.sqrt(16)\nprint(result) \n\n4.0\n\n\nIn this example, the math module is imported, and we use the sqrt function by referencing it through the module’s name.\n\n\nImporting Specific Functions or Classes\nSometimes, you may only need a specific function, class, or variable from a module. Python allows you to import only what you need, which can make your code cleaner and more efficient. When you import specific items, you don’t need to prefix them with the module’s name, as they are directly accessible.\nExample: Importing sqrt from math\n\nfrom math import sqrt\n\n# Directly using the imported sqrt function\nresult = sqrt(16)\nprint(result) \n\n4.0\n\n\nThis method is particularly useful when you need to use a specific function frequently and want to avoid repeatedly typing the module name. However, it’s important to be cautious with this approach, as it can lead to naming conflicts if different modules contain functions or variables with the same name.\nYou can import multiple items from a module by separating them with commas:\n\nfrom math import sqrt, pi\n\n# Using both imported items directly\nprint(sqrt(25))  \nprint(pi)       \n\n5.0\n3.141592653589793\n\n\n\n\nImporting All Names with *\nIn certain cases, you might want to import everything from a module, making all its functions and variables directly accessible without needing to prefix them with the module’s name. This can be done using the * wildcard. However, this method is generally discouraged because it can lead to unexpected name conflicts and make the code harder to understand and debug.\nExample: Importing All from math\n\nfrom math import *\n\n# Using functions and constants directly\nprint(sqrt(16))  \nprint(pi)       \n\n4.0\n3.141592653589793\n\n\nWhile this approach can save typing and is convenient in small scripts or interactive sessions, it is not recommended for larger programs or libraries, where clarity and maintainability are critical.\n\n\nImport with Alias\nModules can sometimes have long names, or you may want to avoid conflicts between modules that share the same name. In these situations, you can import a module under a different name, known as an alias. This allows you to reference the module using a shorter or more descriptive name, making your code more concise and readable.\nExample: Importing math with an Alias\n\nimport math as m\n\n# Using the alias to access functions from the math module\nresult = m.sqrt(16)\nprint(result) \n\n4.0\n\n\nAliases are particularly useful when working with libraries that have long names or when you frequently use a module in your code. They help in maintaining readability while reducing the amount of typing required.\nExample: Avoiding Name Conflicts with Aliases\n\nimport matplotlib.pyplot as plt\n\n# Using aliases in place of longer name\nplt.plot([1, 2, 3], [4, 5, 6])\n\n\n\n\n\n\n\n\n\n\nInstalling matplotlib\n\n\n\nMost installs of Python do not include matplotlib as a base library. You may need to install it. Open up a terminal. Run the following code to install matplotlib.\npip install matplotlib --user\nNote that if you are using a virtual environment, you will need to make sure the virtual environment is activated first.\n\n\n\n\nImporting Modules from a Package\nPython also supports importing modules from a package, which is a collection of modules organized under a common namespace. Packages help in organizing related modules and can be imported similarly to regular modules.\nExample: Importing from a Package\n\nfrom os import path\n\n# Using the path module from the os package\nprint(path.exists(\"example.txt\")) \n\nFalse\n\n\nIn this example, the path module is imported from the os package, and its exists function is used to check if a file exists. Packages are an essential part of Python’s ecosystem, allowing you to organize and distribute your code effectively."
  },
  {
    "objectID": "09_Libraries.html#built-in-libraries",
    "href": "09_Libraries.html#built-in-libraries",
    "title": "9  Introduction to Modules and Libraries",
    "section": "9.3 Built-in Libraries",
    "text": "9.3 Built-in Libraries\nPython comes with a rich set of built-in libraries that cover a wide range of functionalities, from mathematical operations to file handling and beyond. Let’s explore a few common libraries that you will frequently use in your programming journey.\n\nThe math Library\nAs you have already seen, the math library provides mathematical functions and constants.\nExample: Basic Usage of math Library\n\nimport math\n\n# Using constants\nprint(math.pi)\n\n# Using functions\nprint(math.factorial(5))\nprint(math.sqrt(25))\n\n3.141592653589793\n120\n5.0\n\n\n\n\nThe random Library\nThe random library is used for generating random numbers and making random selections.\nExample: Using random Library\n\nimport random\n\n# Generating a random number between 1 and 10\nprint(random.randint(1, 10))  \n\n# Picking a random choice from a list\nchoices = ['apple', 'banana', 'cherry']\nprint(random.choice(choices)) \n\n3\nbanana\n\n\nThis library is particularly useful in simulations, games, and scenarios where randomness is needed."
  },
  {
    "objectID": "09_Libraries.html#creating-custom-modules",
    "href": "09_Libraries.html#creating-custom-modules",
    "title": "9  Introduction to Modules and Libraries",
    "section": "9.4 Creating Custom Modules",
    "text": "9.4 Creating Custom Modules\nCreating your own modules allows you to encapsulate code that can be reused across multiple projects. As you progress in your coding journey, you’ll find this practice invaluable for maintaining clean and organized code.\nExample: Building a Utility Module\nLet’s create a module named utils.py that contains some utility functions:\n\n# utils.py\n\ndef reverse_string(s):\n    \"\"\"Reverse a given string.\"\"\"\n    return s[::-1]\n\ndef is_palindrome(s):\n    \"\"\"Check if a string is a palindrome.\"\"\"\n    return s == s[::-1]\n\nYou can now import and use these functions in any script:\n# main.py\n\nimport utils\n\nword = \"level\"\nprint(utils.reverse_string(word)) \nprint(utils.is_palindrome(word))  \nlevel\nTrue"
  },
  {
    "objectID": "09_Libraries.html#best-practices-for-modules-and-libraries",
    "href": "09_Libraries.html#best-practices-for-modules-and-libraries",
    "title": "9  Introduction to Modules and Libraries",
    "section": "9.5 Best Practices for Modules and Libraries",
    "text": "9.5 Best Practices for Modules and Libraries\nWhen working with modules and libraries in Python, following best practices is essential for creating code that is both maintainable and user-friendly. One of the most important practices is to use descriptive names for your modules. The name of a module should clearly convey its purpose and functionality, making it easier for others (and yourself) to understand what the module does at a glance. For example, a module named math_operations is far more informative than a generic name like utils, as it immediately indicates that the module contains functions related to mathematical operations. Descriptive naming helps prevent confusion, especially in larger projects where multiple modules are used.\nIn addition to naming, keeping functions within a module focused on a single, well-defined task is crucial. Each function should do one thing and do it well. This approach not only makes your code easier to test and debug but also enhances its reusability. For instance, a function that calculates the average of a list of numbers should not also be responsible for reading the numbers from a file. By adhering to the principle of single responsibility, you ensure that each function is modular, making it easier to mix and match functions across different modules and projects.\nDocumentation is another critical aspect of writing good modules. Providing clear and comprehensive docstrings for your modules, functions, and classes is essential for making your code accessible to others. Docstrings should explain what the code does, how to use it, and any important details that users need to be aware of. Well-documented code not only helps others understand and use your modules but also serves as a valuable reference for yourself when you return to the code after some time. Good documentation is a sign of professionalism and care in coding, making your work more reliable and easier to maintain.\nFinally, it is important to avoid side effects in your modules. Side effects occur when a module executes code automatically upon being imported, such as modifying global variables or performing I/O operations. This can lead to unpredictable behavior and bugs, especially if the user is unaware of these side effects. To prevent this, modules should generally be passive, only providing functions and classes without executing any code unless explicitly intended."
  },
  {
    "objectID": "09_Libraries.html#exercises",
    "href": "09_Libraries.html#exercises",
    "title": "9  Introduction to Modules and Libraries",
    "section": "9.6 Exercises",
    "text": "9.6 Exercises\n\nExcersice 1: Creating a Module\nCreate a module arithmetic.py that contains functions for addition, subtraction, multiplication, and division. Write a script that imports this module and performs these operations on user-provided inputs.\n\n\nExcersice 2: Using Built-in Libraries\nWrite a script that uses the random library to generate a random integer and then uses the math library to find the square root of this integer.\n\n\nExcersice 3: Module Composition\nCreate a module geometry.py that contains functions to calculate the area and perimeter of different shapes, such as rectangles, circles, and triangles. Write a script that imports this module and allows the user to input the dimensions of a shape, then outputs the calculated area and perimeter.\n\n\nExcersice 4: Creating a Custom Math Library\nDevelop a custom math module custom_math.py that includes functions for basic arithmetic operations, factorial calculation, and prime number checking. Extend the module by adding a function to calculate the greatest common divisor (GCD) of two numbers. Write a script to demonstrate the usage of each function in the module."
  },
  {
    "objectID": "10_Data_Structures1.html#lists",
    "href": "10_Data_Structures1.html#lists",
    "title": "10  Data Structures: Lists and Tuples",
    "section": "10.1 Lists",
    "text": "10.1 Lists\nIn Python, lists are one of the most commonly used data structures due to their flexibility and ease of use. A list is a mutable, ordered collection of elements, which means the elements in a list can be changed after the list is created, and they are stored in a specific order. This makes lists ideal for storing sequences of data that might need to be altered during the execution of a program.\n\n10.1.1 Creating Lists\nLists in Python are defined using square brackets ([]), with each element separated by a comma. A list can contain elements of any data type, including integers, floats, strings, Booleans, and even other lists.\nExamples:\n\n# A list of integers\ninteger_list = [1, 2, 3, 4, 5]\n\n# A list of mixed data types\nmixed_list = [42, \"apple\", 3.14, True]\n\n# A list of lists\nlists_list = [integer_list, mixed_list]\n\nThe flexibility of lists allows you to store a wide variety of data in a single collection, making them useful in many programming contexts, such as storing records, handling input, and building dynamic datasets.\n\n\n10.1.2 Accessing Elements in a List\nEach element in a list is associated with an index—an integer representing the element’s position in the list. In Python, indices start at 0, meaning the first element is accessed with index 0, the second element with index 1, and so on. Negative indices can also be used to access elements from the end of the list, with -1 referring to the last element, -2 to the second-to-last, and so on.\nExamples:\n\n# Accessing elements by positive index\nmy_list = [10, 20, 30, 40]\nprint(my_list[0])  # Output: 10\nprint(my_list[2])  # Output: 30\n\n# Accessing elements by negative index\nprint(my_list[-1])  # Output: 40\nprint(my_list[-2])  # Output: 30\n\n10\n30\n40\n30\n\n\n\n\n10.1.3 Modifying Lists\nOne of the most powerful features of lists is their mutability. This means that after a list is created, its elements can be changed, added, or removed without creating a new list. There are several ways to modify lists in Python.\n\nChanging Elements\nYou can change individual elements in a list by assigning a new value to a specific index:\n\nmy_list = [1, 2, 3]\nmy_list[1] = 99  \nprint(my_list)  \n\n[1, 99, 3]\n\n\n\n\nAdding Elements\nYou can add elements to a list using the append() method (to add a single element) or the extend() method (to add multiple elements):\n\n# Adding a single element\nmy_list = [1, 2, 3]\nmy_list.append(4)\nprint(my_list)\n\n# Adding multiple elements\nmy_list.extend([5, 6])\nprint(my_list)\n\n[1, 2, 3, 4]\n[1, 2, 3, 4, 5, 6]\n\n\nYou can also use the insert() method to add an element at a specific index:\n\nmy_list = [1, 2, 3]\nmy_list.insert(1, \"new\")\nprint(my_list)  \n\n[1, 'new', 2, 3]\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn Python, a method is a function that is associated with an object. Every method is a function, but not every function is a method. The key difference is that methods are called on objects, and they are designed to perform actions related to those objects. The syntax for calling a method involves the dot notation, where you first specify the object and then call the method.\nMethods are tightly bound to the object they belong to and often manipulate or interact with the data stored in the object. Python has built-in methods for its standard data types like lists, strings, dictionaries, etc.\n\n\n\n\nRemoving Elements\nElements can be removed from a list using the remove() method (to remove the first occurrence of a specific element) or the pop() method (to remove an element by its index):\n\n# Removing an element by value\nmy_list = [1, 2, 3, 2]\nmy_list.remove(2)\nprint(my_list)  \n\n# Removing an element by index\nmy_list.pop(1) #note that this returns the value being removed\nprint(my_list)\n\n[1, 3, 2]\n[1, 2]\n\n\nTo clear all elements from a list, use the clear() method:\n\nmy_list = [1, 2, 3]\nmy_list.clear()\nprint(my_list)\n\n[]\n\n\n\n\n\n10.1.4 Slicing Lists\nIn addition to accessing individual elements, Python allows you to slice lists, which means extracting a portion of the list to create a new list. Slicing is done using the colon (:) operator, with the format list[start:end]. The start index is inclusive, while the end index is exclusive.\nExamples:\n\nmy_list = [10, 20, 30, 40, 50]\n\n# Extract elements from index 1 to 3 (2nd to 4th elements)\nprint(my_list[1:4])  # Output: [20, 30, 40]\n\n# Extract elements from the start to index 3\nprint(my_list[:4])  # Output: [10, 20, 30, 40]\n\n# Extract elements from index 2 to the end\nprint(my_list[2:])  # Output: [30, 40, 50]\n\n[20, 30, 40]\n[10, 20, 30, 40]\n[30, 40, 50]\n\n\nSlicing can also be used with a step value, which specifies how many elements to skip between items:\n\n# Extract every other element\nprint(my_list[::2]) \n\n[10, 30, 50]\n\n\n\n\n10.1.5 Common List Operations\nPython provides several built-in functions and operators that can be applied to lists. Below are some of the most commonly used list operations:\n\nChecking Length: You can find the number of elements in a list using the len() function:\n\nmy_list = [10, 20, 30]\nprint(len(my_list))\n\n3\n\n\nMembership Testing: You can check whether an element is in a list using the in keyword:\n\nmy_list = [10, 20, 30]\nprint(20 in my_list) \n\nTrue\n\n\nSorting Lists: Lists can be sorted in place using the sort() method, or a sorted copy of the list can be returned using the sorted() function:\n\nmy_list = [3, 1, 4, 1, 5, 9]\nmy_list.sort()  # Sort the list in place\nprint(my_list)\n\n[1, 1, 3, 4, 5, 9]\n\n\nReversing a List: You can reverse the order of elements in a list using the reverse() method:\n\nmy_list = [1, 2, 3]\nmy_list.reverse()\nprint(my_list) \n\n[3, 2, 1]\n\n\n\n\n\n10.1.6 Iterating Over Lists\nLists are iterable, which means you can loop through the elements using a for loop:\n\nmy_list = [\"apple\", \"banana\", \"cherry\"]\nfor fruit in my_list:\n    print(fruit)\n\napple\nbanana\ncherry\n\n\nYou can also iterate over both the index and the element using the enumerate() function:\nmy_list = [\"apple\", \"banana\", \"cherry\"]\nfor index, fruit in enumerate(my_list):\n    print(f\"Index {index}: {fruit}\")\n\nNesting Lists\nLists can contain other lists as elements, allowing you to create more complex data structures like matrices or grids. This is known as nesting.\nExample:\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n# Accessing the second element of the first list\nprint(matrix[0][1])  # Output: 2\n\n# Iterating over nested lists\nfor row in matrix:\n    print(row)\n\n2\n[1, 2, 3]\n[4, 5, 6]\n[7, 8, 9]\n\n\n\n\nLists and Built-in Libraries\nLists can be used effectively with common Python libraries. For example, the random module allows for random selection of elements from a list:\nExample:\n\nimport random\n\nfruits = [\"apple\", \"banana\", \"cherry\", \"date\"]\nprint(random.choice(fruits))  # Randomly selects and prints one fruit\n\nbanana"
  },
  {
    "objectID": "10_Data_Structures1.html#tuples",
    "href": "10_Data_Structures1.html#tuples",
    "title": "10  Data Structures: Lists and Tuples",
    "section": "10.2 Tuples",
    "text": "10.2 Tuples\nWhile lists offer flexibility through their mutability, Python also provides tuples, which are similar in structure but immutable. Once a tuple is created, its elements cannot be changed. This immutability makes tuples useful for representing fixed collections of items that should not or cannot change throughout the execution of a program. Tuples are ideal when you need to ensure data integrity, such as coordinates, configuration settings, or when passing multiple values from functions where immutability is expected.\n\n10.2.1 Creating Tuples\nTuples are defined using parentheses () and can hold elements of any data type, much like lists. However, since they are immutable, you cannot modify the elements of a tuple after it is created.\nSyntax:\n\n# Creating a tuple\nmy_tuple = (10, 20, 30)\n\nIt’s also possible to create tuples without using parentheses, though this is less common:\n\nmy_tuple = 10, 20, 30\n\nTuples can contain elements of different types:\n\nmixed_tuple = (1, \"apple\", 3.14, True)\n\nTuples with a single element need to have a comma after the element to avoid confusion with parentheses used in expressions:\n\nsingle_element_tuple = (5,)\nprint(type(single_element_tuple))\n\n&lt;class 'tuple'&gt;\n\n\n\n\n10.2.2 Accessing Tuple Elements\nLike lists, tuples are indexed starting at 0, and individual elements can be accessed using their index. However, since tuples are immutable, you cannot modify their elements.\nExamples:\n\nmy_tuple = (10, 20, 30, 40)\n\n# Accessing the first element\nprint(my_tuple[0]) \n\n# Accessing the last element using negative indexing\nprint(my_tuple[-1]) \n\n10\n40\n\n\nYou can slice tuples just like lists, returning a new tuple containing the specified range of elements:\n\n# Slicing a tuple\nprint(my_tuple[1:3]) \n\n(20, 30)\n\n\n\n\n10.2.3 Tuple Operations\nAlthough tuples are immutable, there are still several operations you can perform on them:\n\nLength of a Tuple: You can find the number of elements in a tuple using the len() function:\n\nmy_tuple = (10, 20, 30)\nprint(len(my_tuple))  \n\n3\n\n\nMembership Testing: Use the in keyword to check whether an element exists in a tuple:\n\nmy_tuple = (10, 20, 30)\nprint(20 in my_tuple)  \n\nTrue\n\n\nIterating Over a Tuple: Tuples are iterable, so you can loop through their elements using a for loop:\n\nfor item in my_tuple:\n    print(item)\n\n10\n20\n30\n\n\nIndexing and Slicing: Like lists, tuples support indexing and slicing:\n\nmy_tuple = (10, 20, 30, 40)\nprint(my_tuple[1:3])  \n\n(20, 30)\n\n\n\n\n\n10.2.4 Nested Tuples\nTuples can be nested inside other tuples, allowing you to create multi-level data structures. This is useful when organizing complex data, such as in multidimensional arrays or coordinate systems.\nExample:\n\nnested_tuple = ((1, 2), (3, 4), (5, 6))\n\n# Accessing the first tuple\nprint(nested_tuple[0])  \n\n# Accessing an element from a nested tuple\nprint(nested_tuple[0][1])  \n\n(1, 2)\n2\n\n\n\n\n10.2.5 Unpacking Tuples\nOne of the most powerful features of tuples is tuple unpacking, which allows you to assign the elements of a tuple to individual variables in a single statement.\nExample:\n\n# Unpacking a tuple into variables\ncoordinates = (10, 20)\nx, y = coordinates\nprint(x)  \nprint(y)  \n\n10\n20\n\n\nTuple unpacking is especially useful when functions return multiple values in a tuple, allowing you to capture and work with these values directly.\nExample:\n\ndef rectangle_properties(length, width):\n    area = length * width\n    perimeter = 2 * (length + width)\n    return (area, perimeter)\n\n# Unpacking the returned tuple into variables\narea, perimeter = rectangle_properties(5, 10)\nprint(f\"Area: {area}, Perimeter: {perimeter}\")\n\nArea: 50, Perimeter: 30\n\n\n\n\n10.2.6 Tuple Methods\nSince tuples are immutable, they have fewer methods compared to lists. However, they do provide two useful methods:\n\ncount(): Returns the number of times a specified value appears in the tuple.\n\nmy_tuple = (1, 2, 2, 3, 2)\nprint(my_tuple.count(2))  \n\n3\n\n\nindex(): Returns the index of the first occurrence of a specified value.\n\nmy_tuple = (1, 2, 3)\nprint(my_tuple.index(2)) \n\n1"
  },
  {
    "objectID": "10_Data_Structures1.html#list-comprehension",
    "href": "10_Data_Structures1.html#list-comprehension",
    "title": "10  Data Structures: Lists and Tuples",
    "section": "10.3 List Comprehension",
    "text": "10.3 List Comprehension\nIn Python, list comprehension provides a concise way to generate lists. It offers a more readable and often more efficient alternative to using loops and append() to build lists. List comprehension allows you to apply an expression to each element in a sequence and optionally include conditional statements to filter elements. This compact syntax makes it easy to create lists based on existing sequences or from operations.\n\n10.3.1 Basic Syntax of List Comprehension\nThe basic syntax of list comprehension is:\n[expression for item in iterable]\n\nexpression: This is the operation or value you want to apply to each item in the iterable.\nitem: Each element from the iterable (e.g., a list, tuple, or string).\niterable: The sequence of elements to loop over (e.g., a list, range, or other iterable object).\n\nThis simple form of list comprehension generates a new list by evaluating the expression for each element in the iterable.\nExample: Creating a list of squares\n\nsquares = [x**2 for x in range(5)]\nprint(squares) \n\n[0, 1, 4, 9, 16]\n\n\nIn this example, for each value x in range(5), Python evaluates x**2 and adds the result to the new list. The result is a list of the squares of the numbers from 0 to 4.\n\n\n10.3.2 List Comprehension with Conditional Logic\nList comprehension can include conditional logic, allowing you to filter elements or apply an operation only when a condition is met. The syntax for adding a condition is as follows:\n[expression for item in iterable if condition]\nThe condition is a logical statement that is evaluated for each item in the iterable. Only items for which the condition evaluates to True are included in the resulting list.\nExample: Filtering even numbers\n\neven_numbers = [x for x in range(10) if x % 2 == 0]\nprint(even_numbers)  \n\n[0, 2, 4, 6, 8]\n\n\nHere, only numbers that satisfy the condition x % 2 == 0 (i.e., the even numbers) are included in the resulting list.\nYou can also use an if-else expression within list comprehension for more complex logic:\n[expression_if_true if condition else expression_if_false for item in iterable]\nExample: Labeling even and odd numbers\n\nlabels = [\"even\" if x % 2 == 0 else \"odd\" for x in range(5)]\nprint(labels)  \n\n['even', 'odd', 'even', 'odd', 'even']\n\n\nIn this case, the comprehension adds the string \"even\" to the list if x is divisible by 2 and \"odd\" otherwise.\n\n\n10.3.3 Nested List Comprehension\nList comprehension can also be nested to create lists from multidimensional structures, such as matrices. Nested list comprehensions are powerful but can become harder to read if not used carefully.\nThe basic syntax for nested list comprehension is:\n[expression for item1 in iterable1 for item2 in iterable2]\nExample: Flattening a matrix (a list of lists)\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nflat_list = [num for row in matrix for num in row]\nprint(flat_list) \n\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nIn this example, we loop over each row in the matrix, and for each row, we loop over each number, adding it to a single list (flat_list).\nExample: Multiplying elements in a matrix by 2\n\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\ndoubled_matrix = [[num * 2 for num in row] for row in matrix]\nprint(doubled_matrix)\n\n[[2, 4, 6], [8, 10, 12], [14, 16, 18]]\n\n\nIn this case, the list comprehension multiplies each element in the matrix by 2, resulting in a new matrix where all values are doubled.\n\n\n10.3.4 List Comprehension with Built-in Functions\nYou can combine list comprehensions with built-in Python functions to perform more complex transformations and calculations. This is a common pattern when dealing with operations such as string manipulation, mathematical calculations, or other functional transformations.\nExample: Using the len() function\n\nwords = [\"apple\", \"banana\", \"cherry\"]\nword_lengths = [len(word) for word in words]\nprint(word_lengths)  \n\n[5, 6, 6]\n\n\nHere, the list comprehension applies the len() function to each word in the list words, resulting in a list of the word lengths.\nExample: Using sum() with list comprehension Suppose we have a list of lists representing test scores for different students. We can calculate the sum of each student’s test scores using list comprehension:\n\nscores = [[75, 80, 85], [60, 70, 75], [90, 95, 100]]\ntotal_scores = [sum(student_scores) for student_scores in scores]\nprint(total_scores) \n\n[240, 205, 285]\n\n\nIn this example, sum() calculates the total score for each student, and list comprehension gathers these sums into a new list total_scores.\n\n\n10.3.5 List Comprehension vs. Loops\nList comprehension is often favored over traditional loops because it provides a more compact and readable syntax. However, there are cases where a loop might be more appropriate, especially when the logic is complex, or when you need to modify elements in place.\nExample: Traditional loop\n\nsquares = []\nfor x in range(5):\n    squares.append(x**2)\nprint(squares) \n\n[0, 1, 4, 9, 16]\n\n\nEquivalent list comprehension:\n\nsquares = [x**2 for x in range(5)]\nprint(squares)  \n\n[0, 1, 4, 9, 16]\n\n\nList comprehension is faster for simple operations because it avoids the overhead of repeatedly calling append() and performing function calls. However, for more complex logic, such as multiple conditional statements or nested loops, the clarity of traditional loops might outweigh the brevity of list comprehension.\n\n\n10.3.6 List Comprehension with External Libraries\nList comprehension can be used effectively with other basic libraries like math or random.\nExample: Using math.sqrt() with list comprehension\n\nimport math\nnumbers = [1, 4, 9, 16, 25]\nsquare_roots = [math.sqrt(num) for num in numbers]\nprint(square_roots)  \n\n[1.0, 2.0, 3.0, 4.0, 5.0]\n\n\nIn this example, math.sqrt() is applied to each number in the list numbers, resulting in a list of square roots.\nExample: Using random.randint() You can also use list comprehension with the random module to generate random numbers:\n\nimport random\nrandom_numbers = [random.randint(1, 100) for _ in range(5)]\nprint(random_numbers)  \n\n[46, 65, 17, 40, 26]\n\n\nHere, the _ is a placeholder variable (indicating that the value is not important), and random.randint() generates a random integer for each iteration.\n\n\n10.3.7 Limitations of List Comprehension\nWhile list comprehension is a powerful tool, there are some cases where it may not be the best choice:\n\nReadability: Overusing or nesting list comprehensions can make code difficult to read and maintain, especially when working with complex logic. In such cases, using traditional loops or helper functions might result in clearer and more maintainable code.\nComplex operations: When performing complex operations with multiple steps, it’s often better to use traditional loops to avoid confusion and improve code clarity.\nMemory efficiency: Since list comprehensions create a new list in memory, they might not be suitable for extremely large datasets. In such cases, consider using generator expressions (which we will cover in later sections) to optimize memory usage.\n\n\n\n10.3.8 Example: Practical Applications of List Comprehension\nTo conclude, let’s explore a practical application of list comprehension in data processing.\nExample: Filtering and transforming data Suppose we are processing a list of student scores, and we want to filter out scores below 50 and increase the remaining scores by 10%. We can accomplish this efficiently with list comprehension.\n\nscores = [45, 67, 85, 30, 78, 92, 40]\nadjusted_scores = [score * 1.1 for score in scores if score &gt;= 50]\nprint(adjusted_scores)  \n\n[73.7, 93.50000000000001, 85.80000000000001, 101.2]\n\n\nIn this example, only scores greater than or equal to 50 are included, and each selected score is increased by 10%. List comprehension simplifies the process of filtering and transforming the data in a single readable line."
  },
  {
    "objectID": "10_Data_Structures1.html#exercises",
    "href": "10_Data_Structures1.html#exercises",
    "title": "10  Data Structures: Lists and Tuples",
    "section": "10.4 Exercises",
    "text": "10.4 Exercises\n\nExcersice 1: Basic List Operations\n\nCreate a list named fruits with the values: “apple”, “banana”, “cherry”.\n\nAdd the fruit “orange” to the list.\n\nRemove “banana” from the list.\n\nPrint the second fruit in the list.\n\nPrint the length of the list.\n\n\n\nExcersice 2: Modifying Lists\n\nCreate a list numbers containing the values 1, 2, 3, 4, and 5.\n\nReplace the third element in the list with the value 10.\n\nAdd the number 6 to the end of the list.\n\nInsert the number 0 at the beginning of the list.\n\nPrint the updated list.\n\n\n\nExcersice 3: Slicing Lists\nGiven the list colors = [\"red\", \"green\", \"blue\", \"yellow\", \"purple\"],\na. Slice and print the first three colors.\nb. Slice and print the last two colors.\nc. Slice and print every second color in the list.\n\n\nExcersice 4: Nested Lists\nCreate a nested list matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]].\na. Print the element at the first row and second column.\nb. Change the element at the second row and third column to 10.\nc. Print the entire second row.\n\n\nExcersice 5: Basic Tuple Operations\n\nCreate a tuple my_tuple with values: 10, 20, 30, 40, 50.\n\nPrint the value at index 2.\n\nTry to change the value at index 1 to 15 (what happens?).\n\nPrint the length of the tuple.\n\n\n\nExcersice 6: Tuple Unpacking\n\nCreate a tuple dimensions = (1920, 1080).\n\nUnpack the tuple into variables width and height.\n\nPrint the values of width and height.\n\n\n\nExcersice 7: Returning Tuples from Functions\n\nWrite a function calculate_stats(numbers) that takes a list of numbers and returns a tuple containing the sum and the average of the list.\n\nCall the function with the list [10, 20, 30, 40, 50] and unpack the returned tuple into variables total_sum and average.\n\nPrint the values of total_sum and average.\n\n\n\nExcersice 8: Nested Tuples\nGiven the nested tuple nested = ((1, 2), (3, 4), (5, 6)),\na. Print the first element of the second tuple.\nb. Try to change the second element of the third tuple to 7 (what happens?).\n\n\nExcersice 9: Basic List Comprehension\n\nCreate a list comprehension that generates a list of squares of numbers from 1 to 10.\n\nCreate a list comprehension that generates a list of even numbers between 1 and 20.\n\n\n\nExcersice 10: Basic List Comprehension\n\nCreate a list comprehension that generates a list of all numbers between 1 and 50 that are divisible by 3.\n\nCreate a list comprehension that generates a list of all numbers between 1 and 100 that are divisible by both 2 and 5.\n\n\n\nExcersice 11: Nested List Comprehension\nUsing nested list comprehension, create a list of all possible combinations of two numbers, where the first number is from the list [1, 2, 3] and the second number is from the list [4, 5, 6].\n\n\nExcersice 12: String Manipulation with List Comprehension\nGiven the list words = [\"apple\", \"banana\", \"cherry\", \"date\"],\na. Create a list comprehension that returns the lengths of each word in the list.\nb. Create a list comprehension that converts each word in the list to uppercase.\n\n\nExcersice 13: Tuples and List Comprehension\nGiven a list of tuples representing students and their scores:\nstudents = [(\"Alice\", 85), (\"Bob\", 60), (\"Charlie\", 95), (\"David\", 70)],\na. Use a list comprehension to create a list of names of students who scored 70 or above.\nb. Use a list comprehension to create a list of tuples where each student’s score is increased by 5 points.\n\n\nExcersice 14: Matrix Flattening\nGiven a nested list (matrix): matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], use list comprehension to flatten the matrix into a single list."
  },
  {
    "objectID": "11_Data_Structures2.html#dictionaries",
    "href": "11_Data_Structures2.html#dictionaries",
    "title": "11  Data Structures: Dictionaries and Sets",
    "section": "11.1 Dictionaries",
    "text": "11.1 Dictionaries\nA dictionary in Python is a versatile and powerful data structure that stores data in key-value pairs. Unlike lists, which use numerical indices, dictionaries use keys that can be of any immutable data type (e.g., strings, numbers, tuples). This makes dictionaries an ideal structure for tasks that require fast lookups, updates, and association between related pieces of data.\n\n11.1.1 Creating a Dictionary\nDictionaries are created using curly braces {} or the dict() constructor, and key-value pairs are defined using the syntax key: value. Let’s explore various ways to create dictionaries:\n\nLiteral Notation\nThe most straightforward way to create a dictionary is by using curly braces:\n\n# Creating a dictionary with student grades\ngrades = {\n    \"John\": 85,\n    \"Alice\": 92,\n    \"Bob\": 78\n}\n\n\n\nUsing the dict() Constructor\nAlternatively, dictionaries can be created using the dict() constructor, which allows for the creation of dictionaries using keyword arguments or iterables of key-value pairs:\n\n# Creating a dictionary using keyword arguments\ngrades = dict(John=85, Alice=92, Bob=78)\n\n# Creating a dictionary from a list of tuples\ngrades = dict([(\"John\", 85), (\"Alice\", 92), (\"Bob\", 78)])\n\nIn this example, both methods create the same dictionary as the one using literal notation.\n\n\n\n11.1.2 Accessing Values\nTo access values in a dictionary, you use the key as the index. This allows for quick lookup time, which is one of the key advantages of dictionaries over lists or tuples.\n\n# Accessing the value associated with the key \"Alice\"\nprint(grades[\"Alice\"])  \n\n92\n\n\nIf the key is not found, Python raises a KeyError. To avoid this, you can use the get() method, which returns None or a specified default value if the key does not exist:\n\n# Safely accessing a key\nprint(grades.get(\"David\", \"Not Found\")) \n\nNot Found\n\n\nNote the second argument for the get method is a value that will be returned if the specified key does not exist. The default is None.\n\n\n11.1.3 Adding and Modifying Entries\nDictionaries are mutable, meaning you can add or modify key-value pairs after the dictionary has been created.\n\nModifying Values\nTo modify the value associated with an existing key, simply assign a new value to that key:\n\n# Modifying the value associated with \"John\"\ngrades[\"John\"] = 88\nprint(grades)  \n\n{'John': 88, 'Alice': 92, 'Bob': 78}\n\n\n\n\nAdding New Key-Value Pairs\nTo add a new key-value pair, use the same syntax as modifying an existing pair:\n\n# Adding a new key-value pair\ngrades[\"David\"] = 90\nprint(grades) \n\n{'John': 88, 'Alice': 92, 'Bob': 78, 'David': 90}\n\n\n\n\n\n11.1.4 Deleting Key-Value Pairs\nThere are several ways to remove key-value pairs from a dictionary:\n\nUsing the del Statement\nThe del statement removes the key-value pair from the dictionary:\n\n# Removing the key-value pair for \"Bob\"\ndel grades[\"Bob\"]\nprint(grades) \n\n{'John': 88, 'Alice': 92, 'David': 90}\n\n\n\n\nUsing the pop() Method\nThe pop() method removes a key-value pair and returns the value. If the key is not found, it raises a KeyError, unless a default value is provided.\n\n# Removing and returning the value for \"Alice\"\nalice_grade = grades.pop(\"Alice\")\nprint(alice_grade)\nprint(grades)  \n\n92\n{'John': 88, 'David': 90}\n\n\n\n\n\n11.1.5 Dictionary Methods\nDictionaries come with a variety of built-in methods that simplify common tasks, such as adding, removing, and checking for keys and values.\n\nkeys(), values(), and items()\n\nkeys() returns a view of all the keys in the dictionary.\nvalues() returns a view of all the values in the dictionary.\nitems() returns a view of all key-value pairs as tuples.\n\n\nprint(grades.keys())   \nprint(grades.values()) \nprint(grades.items()) \n\ndict_keys(['John', 'David'])\ndict_values([88, 90])\ndict_items([('John', 88), ('David', 90)])\n\n\n\n\nupdate()\nThe update() method allows you to merge two dictionaries or add key-value pairs from another iterable:\n\n# Merging dictionaries\nextra_grades = {\"Eve\": 85, \"Charlie\": 79}\ngrades.update(extra_grades)\nprint(grades) \n\n{'John': 88, 'David': 90, 'Eve': 85, 'Charlie': 79}\n\n\n\n\nclear()\nThe clear() method removes all key-value pairs from the dictionary:\n\ngrades.clear()\nprint(grades) \n\n{}\n\n\n\n\n\n11.1.6 Iterating Over Dictionaries\nThere are several ways to iterate over dictionaries, depending on whether you need keys, values, or both:\n\nIterating Over Keys\nBy default, iterating over a dictionary yields its keys:\n\nfor student in grades:\n    print(student)\n\n\n\nIterating Over Values\nYou can iterate over the values by using the values() method:\n\nfor grade in grades.values():\n    print(grade)\n\n\n\nIterating Over Key-Value Pairs\nThe items() method allows you to iterate over both keys and values simultaneously:\nfor student, grade in grades.items():\n    print(f\"{student}: {grade}\")\n\n\n\n11.1.7 Dictionary Comprehension\nLike list comprehensions, Python also supports dictionary comprehensions, which provide a concise way to create dictionaries from iterables.\n\n# Creating a dictionary of squares\nsquares = {x: x**2 for x in range(1, 6)}\nprint(squares)\n\n{1: 1, 2: 4, 3: 9, 4: 16, 5: 25}\n\n\n\n\n11.1.8 Practical Applications of Dictionaries\nDictionaries are used in a variety of real-world applications, particularly where fast lookups or associations between pieces of data are needed.\n\nFrequency Count\nOne common use of dictionaries is counting the frequency of elements in a collection. Here is an example that counts the occurrence of each character in a string:\n\ndef char_frequency(text):\n    freq = {}\n    for char in text:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n    return freq\n\ntext = \"data science\"\nprint(char_frequency(text))\n\n{'d': 1, 'a': 2, 't': 1, ' ': 1, 's': 1, 'c': 2, 'i': 1, 'e': 2, 'n': 1}\n\n\n\n\nStoring Configuration Settings\nDictionaries are often used to store configuration settings because they allow easy lookups by key:\n\nconfig = {\n    \"host\": \"localhost\",\n    \"port\": 8080,\n    \"debug\": True\n}\nprint(config[\"host\"])\n\nlocalhost\n\n\n\n\nCaching Computations\nDictionaries can be used to cache results of expensive computations to avoid recalculating them:\n\n\n\n\n\n\ncache\n\n\n\nA cache (pronounced “cash”) is memory used to store something, usually data, temporarily in a computing environment.\n\n\n\nfactorial_cache = {}\n\ndef factorial(n):\n    if n in factorial_cache:\n        return factorial_cache[n]\n    if n == 0:\n        result = 1\n    else:\n        result = n * factorial(n-1)\n    factorial_cache[n] = result\n    return result\n\nprint(factorial(5))  \nprint(factorial_cache)\n\n120\n{0: 1, 1: 1, 2: 2, 3: 6, 4: 24, 5: 120}\n\n\nBy caching the results, subsequent calls to factorial(n) for previously computed values are faster, as they avoid redundant calculations.\n\n\n\n11.1.9 Using **kwargs in Functions\nIn Python, dictionaries are often used to pass and manage named arguments to functions. One powerful feature that leverages dictionaries is the **kwargs mechanism, which allows functions to accept an arbitrary number of keyword arguments (recall Chapter 8). These keyword arguments are collected into a dictionary, which provides flexibility when you do not know in advance what arguments might be passed to a function.\nThe **kwargs construct is particularly useful when writing functions that need to accept a variable number of named parameters or when extending existing functions with new optional arguments without changing their function signature.\n\nHow **kwargs Works\nThe term kwargs stands for “keyword arguments,” and when used with **, it allows you to pass a variable number of named arguments to a function. Inside the function, these keyword arguments are captured as a dictionary.\n\ndef print_student_scores(**kwargs):\n    for student, score in kwargs.items():\n        print(f\"{student}: {score}\")\n\n# Calling the function with multiple keyword arguments\nprint_student_scores(John=85, Alice=92, Bob=78)\n\nJohn: 85\nAlice: 92\nBob: 78\n\n\nIn the example above, the function print_student_scores() accepts any number of keyword arguments and prints them. The **kwargs parameter collects the keyword arguments as a dictionary, where the keys are the argument names (John, Alice, Bob), and the values are the respective scores.\n\n\nAccessing and Using **kwargs\nOnce inside the function, **kwargs behaves like a normal dictionary. You can access, iterate over, and modify its elements just as you would with any other dictionary.\n\ndef get_student_grade(**kwargs):\n    student = kwargs.get(\"student\")\n    grade = kwargs.get(\"grade\")\n    if student and grade:\n        print(f\"{student}'s grade is {grade}\")\n    else:\n        print(\"Missing student or grade information\")\n\n# Providing student and grade as keyword arguments\nget_student_grade(student=\"John\", grade=85)\n\n# Missing one argument\nget_student_grade(student=\"Alice\")  \n\nJohn's grade is 85\nMissing student or grade information\n\n\nIn this example, the kwargs.get() method is used to safely retrieve values from the kwargs dictionary. If the key does not exist, get() returns None, which prevents the function from throwing a KeyError.\n\n\nCombining **kwargs with Regular and Positional Arguments\nYou can combine **kwargs with regular and positional arguments. However, **kwargs must always be placed after regular arguments in the function signature:\n\ndef student_info(course, **kwargs):\n    print(f\"Course: {course}\")\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\n\n# Calling the function with both positional and keyword arguments\nstudent_info(\"Mathematics\", name=\"John\", grade=90, age=20)\n\nCourse: Mathematics\nname: John\ngrade: 90\nage: 20\n\n\nHere, course is a regular argument, and the remaining keyword arguments (e.g., name, grade, and age) are captured into the kwargs dictionary.\n\n\nPassing a Dictionary as **kwargs\nIf you already have a dictionary of key-value pairs, you can pass it to a function using ** to unpack the dictionary into keyword arguments.\n\ndef print_details(name, age, occupation):\n    print(f\"Name: {name}, Age: {age}, Occupation: {occupation}\")\n\n# Creating a dictionary of arguments\nperson = {\"name\": \"Alice\", \"age\": 30, \"occupation\": \"Data Scientist\"}\n\n# Passing the dictionary as keyword arguments\nprint_details(**person)\n\nName: Alice, Age: 30, Occupation: Data Scientist\n\n\nIn this case, the **person syntax unpacks the dictionary into keyword arguments, allowing you to pass the dictionary directly into the function.\n\n\n**kwargs and Default Arguments\nWhile **kwargs allows for flexible keyword arguments, you can also combine it with default arguments to give function parameters some predefined behavior.\n\ndef log_message(level=\"INFO\", **kwargs):\n    message = kwargs.get(\"message\", \"No message provided\")\n    timestamp = kwargs.get(\"timestamp\", \"No timestamp\")\n    print(f\"[{level}] {timestamp}: {message}\")\n\n# Logging a message with a default level\nlog_message(message=\"System started\", timestamp=\"2023-09-12 10:00:00\")\n\n# Overriding the default level\nlog_message(level=\"ERROR\", message=\"System failure\", timestamp=\"2023-09-12 10:01:00\")\n\n[INFO] 2023-09-12 10:00:00: System started\n[ERROR] 2023-09-12 10:01:00: System failure\n\n\nIn this example, the log_message() function uses a default level of “INFO” and then utilizes **kwargs to collect additional information like the message and timestamp.\n\n\nSummary\nThe **kwargs construct provides a flexible way to pass and handle keyword arguments in Python. By collecting all keyword arguments into a dictionary, you gain the ability to write dynamic and adaptable functions. Whether used for configuration settings, logging, or passing optional parameters, **kwargs is a powerful tool that makes functions more reusable and extensible."
  },
  {
    "objectID": "11_Data_Structures2.html#sets",
    "href": "11_Data_Structures2.html#sets",
    "title": "11  Data Structures: Dictionaries and Sets",
    "section": "11.2 Sets",
    "text": "11.2 Sets\nA set in Python is an unordered collection of unique elements. This data structure is useful when you need to store distinct items and perform operations such as union, intersection, difference, or membership testing efficiently. Sets are particularly powerful when handling large datasets where duplication is unnecessary or undesirable.\n\n11.2.1 Creating a Set\nSets are created by placing items inside curly braces {} or by using the set() function. Unlike lists or dictionaries, sets do not maintain any order, and duplicate values are automatically removed. Sets can hold items of any immutable data type, such as numbers, strings, or tuples.\n\nLiteral Notation\nYou can create a set directly by enclosing a sequence of values in curly braces:\n\n# Creating a set of integers\nnumbers = {1, 2, 3, 4, 5}\nprint(numbers)  \n\n# Creating a set of strings\nfruits = {\"apple\", \"banana\", \"cherry\"}\nprint(fruits)  \n\n{1, 2, 3, 4, 5}\n{'banana', 'apple', 'cherry'}\n\n\n\n\nUsing the set() Function\nThe set() function is particularly useful when creating a set from an iterable, such as a list or a string. It automatically removes duplicates:\n\n# Creating a set from a list with duplicate values\nnumbers_list = [1, 2, 2, 3, 4, 4, 5]\nunique_numbers = set(numbers_list)\nprint(unique_numbers) \n\n# Creating a set from a string\nletters = set(\"hello\")\nprint(letters)\n\n{1, 2, 3, 4, 5}\n{'o', 'l', 'e', 'h'}\n\n\n\n\n\n11.2.2 Adding and Removing Elements\n\nAdding Elements\nYou can add elements to a set using the add() method. However, since sets do not allow duplicate values, adding an existing element has no effect:\n\n# Adding elements to a set\nfruits = {\"apple\", \"banana\"}\nfruits.add(\"cherry\")\nprint(fruits)  \n\n# Attempting to add a duplicate element\nfruits.add(\"apple\")\nprint(fruits)  \n\n{'banana', 'apple', 'cherry'}\n{'banana', 'apple', 'cherry'}\n\n\n\n\nRemoving Elements\nThere are multiple ways to remove elements from a set, including the remove(), discard(), and pop() methods:\n\nremove() raises a KeyError if the element does not exist.\ndiscard() does not raise an error if the element is not found.\npop() removes and returns an arbitrary element, as sets are unordered.\n\n\n# Removing elements using remove()\nfruits.remove(\"banana\")\nprint(fruits)  \n\n# Using discard() to remove an element safely\nfruits.discard(\"apple\")\nprint(fruits)  \n\n# Removing a random element with pop()\nrandom_fruit = fruits.pop()\nprint(random_fruit)  \nprint(fruits)  \n\n{'apple', 'cherry'}\n{'cherry'}\ncherry\nset()\n\n\n\n\n\n11.2.3 Set Operations\nOne of the most powerful features of sets is their support for mathematical operations such as union, intersection, difference, and symmetric difference. These operations are efficient and allow for concise and readable code.\n\nUnion (| or union())\nThe union operation combines all elements from two sets, excluding duplicates. This operation can be performed using the | operator or the union() method.\n\nset1 = {1, 2, 3}\nset2 = {3, 4, 5}\n\n# Using the | operator\nunion_set = set1 | set2\nprint(union_set)  \n\n# Using the union() method\nunion_set = set1.union(set2)\nprint(union_set)  \n\n{1, 2, 3, 4, 5}\n{1, 2, 3, 4, 5}\n\n\n\n\nIntersection (& or intersection())\nThe intersection operation returns only the elements that are present in both sets. It can be performed using the & operator or the intersection() method.\n\nset1 = {1, 2, 3}\nset2 = {2, 3, 4}\n\n# Using the & operator\nintersection_set = set1 & set2\nprint(intersection_set) \n\n# Using the intersection() method\nintersection_set = set1.intersection(set2)\nprint(intersection_set)  \n\n{2, 3}\n{2, 3}\n\n\n\n\nDifference (- or difference())\nThe difference operation returns the elements that are in the first set but not in the second. This can be done using the - operator or the difference() method.\n\nset1 = {1, 2, 3}\nset2 = {2, 3, 4}\n\n# Using the - operator\ndifference_set = set1 - set2\nprint(difference_set) \n\n# Using the difference() method\ndifference_set = set1.difference(set2)\nprint(difference_set)  \n\n{1}\n{1}\n\n\n\n\nSymmetric Difference (^ or symmetric_difference())\nThe symmetric difference operation returns elements that are in either of the sets but not in both. This operation can be performed using the ^ operator or the symmetric_difference() method.\n\nset1 = {1, 2, 3}\nset2 = {2, 3, 4}\n\n# Using the ^ operator\nsym_diff_set = set1 ^ set2\nprint(sym_diff_set)  \n\n# Using the symmetric_difference() method\nsym_diff_set = set1.symmetric_difference(set2)\nprint(sym_diff_set)  \n\n{1, 4}\n{1, 4}\n\n\n\n\n\n11.2.4 Checking for Subsets and Supersets\nSets also support operations that allow you to check whether one set is a subset or superset of another. These operations are particularly useful in scenarios where you need to compare sets.\n\nSubset (&lt;= or issubset())\nA set A is a subset of set B if all elements of A are also in B. You can check for subsets using the &lt;= operator or the issubset() method.\n\nset1 = {1, 2}\nset2 = {1, 2, 3, 4}\n\n# Using the &lt;= operator\nprint(set1 &lt;= set2) \n\n# Using the issubset() method\nprint(set1.issubset(set2))\n\nTrue\nTrue\n\n\n\n\nSuperset (&gt;= or issuperset())\nA set A is a superset of set B if all elements of B are also in A. You can check for supersets using the &gt;= operator or the issuperset() method.\n\nset1 = {1, 2, 3, 4}\nset2 = {1, 2}\n\n# Using the &gt;= operator\nprint(set1 &gt;= set2)  \n\n# Using the issuperset() method\nprint(set1.issuperset(set2))  \n\nTrue\nTrue\n\n\n\n\n\n11.2.5 Frozen Sets\nA frozen set is an immutable version of a set, meaning that once a frozen set is created, its elements cannot be modified (i.e., you cannot add or remove elements). Frozen sets are useful when you need a collection of unique elements that should remain constant throughout the program. You create a frozen set using the frozenset() function:\n\n# Creating a frozen set\nimmutable_set = frozenset([1, 2, 3, 4])\nprint(immutable_set)  \n\n# Attempting to add an element to a frozen set will raise an error\n# immutable_set.add(5)  # Raises AttributeError\n\nfrozenset({1, 2, 3, 4})\n\n\n\n\n11.2.6 Set Comprehensions\nPython provides a concise way to create sets using set comprehensions, similar to list comprehensions. A set comprehension is written with curly braces {} and allows you to define sets based on existing iterables, often including a filtering condition.\n\n# Creating a set of squares for numbers 1 to 5\nsquares = {x**2 for x in range(1, 6)}\nprint(squares)  \n\n# Set comprehension with a condition\neven_squares = {x**2 for x in range(1, 11) if x % 2 == 0}\nprint(even_squares)  \n\n{1, 4, 9, 16, 25}\n{64, 100, 4, 36, 16}\n\n\nSet comprehensions are a powerful tool when you need to transform or filter data while maintaining unique elements.\n\n\n11.2.7 Set Best Practices\nWhile sets are efficient for handling unique elements, there are a few best practices to keep in mind when working with sets in Python:\n\nAvoid Unnecessary Duplicates: Since sets automatically remove duplicates, there’s no need to check for duplicates before adding elements.\nUse Sets for Membership Testing: When you need to check if an item exists in a collection and the collection does not need to maintain order or allow duplicates, sets are the best choice due to their O(1) membership testing time complexity.\nChoose the Right Operation: Use set operations such as union, intersection, and difference to simplify complex data comparison tasks. These operations are more efficient than writing custom loops to achieve the same results.\n\nSets are an invaluable data structure for handling collections of unique items. Their efficiency in membership testing, combined with their ability to perform set operations such as union, intersection, and difference, makes them ideal for a wide variety of tasks, from data processing to mathematical computations. With their unordered nature and automatic deduplication, sets help simplify code and ensure efficient performance, especially when working with large datasets.\n\n\n11.2.8 Combining Dictionaries and Sets\nYou can often combine dictionaries and sets in practical applications. For example, to find unique words and their counts from a list of sentences:\n\ndef unique_words(sentences):\n    word_dict = {}\n    for sentence in sentences:\n        words = set(sentence.split())  # Use a set to find unique words\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n    return word_dict\n\nsentences = [\"data science is great\", \"data science is evolving\"]\nresult = unique_words(sentences)\nprint(result)  # Output: {'data': 2, 'science': 2, 'is': 2, 'great': 1, 'evolving': 1}\n\n{'data': 2, 'is': 2, 'great': 1, 'science': 2, 'evolving': 1}\n\n\nThis function uses sets to ensure that each word in a sentence is only counted once per sentence and then stores the results in a dictionary."
  },
  {
    "objectID": "11_Data_Structures2.html#exercises",
    "href": "11_Data_Structures2.html#exercises",
    "title": "11  Data Structures: Dictionaries and Sets",
    "section": "11.3 Exercises",
    "text": "11.3 Exercises\n\nExcersice 1: Student Grades\nWrite a function called update_grades() that accepts a dictionary of student names and their grades. The function should accept new student names and grades and update the dictionary. Finally, it should return the updated dictionary.\nExample:\ngrades = {\"John\": 85, \"Alice\": 92}\nnew_grades = {\"Bob\": 78, \"Alice\": 95}\n\nupdated_grades = update_grades(grades, **new_grades)\nprint(updated_grades)\nExpected Output:\n{\"John\": 85, \"Alice\": 95, \"Bob\": 78}\n\n\nExcersice 2: Word Frequency Counter\nWrite a function word_frequency(text) that takes a string and returns a dictionary with the frequency count of each word in the string.\nExample:\ntext = \"data science is data fun science is fun\"\nresult = word_frequency(text)\nprint(result)\nExpected Output:\n{'data': 2, 'science': 2, 'is': 2, 'fun': 2}\n\n\nExcersice 3: Dictionary of Squares\nCreate a function squares_dict(n) that generates a dictionary where the keys are numbers from 1 to n and the values are their corresponding squares.\nExample:\nprint(squares_dict(5))\nExpected Output:\n{1: 1, 2: 4, 3: 9, 4: 16, 5: 25}\n\n\nExercise 4: Merge Dictionaries\nWrite a function merge_dictionaries(*args) that accepts any number of dictionaries and merges them into a single dictionary. If a key is repeated, the value from the last dictionary should be retained.\nExample:\ndict1 = {\"a\": 1, \"b\": 2}\ndict2 = {\"b\": 3, \"c\": 4}\ndict3 = {\"d\": 5}\n\nresult = merge_dictionaries(dict1, dict2, dict3)\nprint(result)\nExpected Output:\n{'a': 1, 'b': 3, 'c': 4, 'd': 5}\n\n\nExercise 5: Remove Duplicates\nWrite a function remove_duplicates(lst) that takes a list and returns a new list with all the duplicates removed using a set.\nExample:\nnumbers = [1, 2, 2, 3, 4, 4, 5]\nprint(remove_duplicates(numbers))\nExpected Output:\n[1, 2, 3, 4, 5]\n\n\nExercise 6: Set Operations\nGiven two sets of students enrolled in two different courses, write functions to:\n\nFind students enrolled in both courses.\nFind students enrolled only in the first course.\nFind students enrolled in either course but not both.\n\nExample:\ncourse_A = {\"Alice\", \"Bob\", \"Charlie\", \"David\"}\ncourse_B = {\"Charlie\", \"David\", \"Eve\", \"Frank\"}\n\n# Students in both courses\nprint(students_in_both(course_A, course_B))\n\n# Students only in course A\nprint(only_in_first(course_A, course_B))\n\n# Students in either course but not both\nprint(either_but_not_both(course_A, course_B))\nExpected Output:\n{'Charlie', 'David'}\n{'Alice', 'Bob'}\n{'Alice', 'Bob', 'Eve', 'Frank'}\n\n\nExercise 7: Flexible Function with **kwargs\nWrite a function student_profile(**kwargs) that accepts student information (name, age, grade, etc.) as keyword arguments and prints the information in a readable format.\nExample:\nstudent_profile(name=\"Alice\", age=20, grade=\"A\", major=\"Mathematics\")\nExpected Output:\nName: Alice\nAge: 20\nGrade: A\nMajor: Mathematics\n\n\nExercise 8: Summing Keyword Arguments\nWrite a function sum_values(**kwargs) that takes any number of keyword arguments where the values are integers and returns their sum.\nExample:\nresult = sum_values(a=5, b=10, c=3)\nprint(result)\nExpected Output:\n18"
  },
  {
    "objectID": "12_JSON.html#introduction-to-json",
    "href": "12_JSON.html#introduction-to-json",
    "title": "12  JSON Files in Python",
    "section": "12.1 Introduction to JSON",
    "text": "12.1 Introduction to JSON\nJSON (JavaScript Object Notation) is a widely-used format for data interchange, particularly in web development and API communication. JSON is designed to be both human-readable and machine-readable, making it an ideal choice for data exchange across platforms and programming languages. JSON represents structured data as a series of key-value pairs, much like Python dictionaries, but with a more constrained and universal syntax. It can easily handle data types such as objects, arrays, strings, numbers, booleans, and null values.\n\n12.1.1 Why Use JSON?\nJSON (JavaScript Object Notation) has become the dominant format for data interchange due to its simplicity, flexibility, and widespread support. Here are several key reasons why JSON is preferred in many applications:\n\nLightweight and Efficient: JSON is a minimalistic format that uses a concise structure to represent data. Unlike XML, JSON eliminates the need for heavy markup tags, making it more compact and faster to process. This lightweight nature is especially beneficial in network communication, where reducing data size can significantly improve performance.\nCross-Platform Compatibility: Although JSON originated from JavaScript, it is now a language-independent standard. Most modern programming languages, including Python, Java, C++, and Ruby, offer built-in support for parsing and generating JSON. This makes JSON ideal for systems where data needs to be transferred between different technologies.\nHuman-Readable: JSON’s clear and straightforward syntax makes it easy for humans to read and write. The structure, based on key-value pairs and arrays, is intuitive and similar to Python’s dictionaries and lists, which helps developers quickly understand the data.\nCommon in Web Development: JSON is the default data format for most web APIs. RESTful services, in particular, rely heavily on JSON to structure the data exchanged between clients and servers. Its popularity in web applications makes it a critical skill for developers working with modern web technologies.\nEasy to Parse: JSON is simple to parse in most programming environments. Libraries like Python’s json module provide straightforward methods for converting JSON data into native data structures and vice versa, making JSON a practical choice for data interchange.\n\nOverall, JSON is widely used because it strikes an effective balance between being machine-friendly and human-friendly, making it an optimal choice for a variety of applications.\n\n\n12.1.2 JSON Structure and Data Types\nJSON’s structure is based on two universal data structures:\n\nObjects: Collections of key-value pairs, where keys are strings and values can be any valid JSON type.\nArrays: Ordered lists of values, where each value can be any valid JSON type.\n\nIn addition, JSON supports the following primitive types:\n\nString: A sequence of characters, enclosed in double quotes.\nNumber: Integers or floating-point numbers.\nBoolean: true or false.\nNull: A special value representing the absence of data (null in JSON, None in Python).\n\n\nExample JSON Object\nA typical JSON object that describes a student might look like this:\n{\n    \"name\": \"Alice\",\n    \"age\": 21,\n    \"major\": \"Statistics\",\n    \"graduated\": false,\n    \"courses\": [\"Calculus\", \"Linear Algebra\", \"Statistics\"],\n    \"details\": {\n        \"GPA\": 3.8,\n        \"credits_completed\": 95\n    }\n}\nHere, the JSON object contains several fields:\n\nname: A string representing the student’s name.\nage: A number representing the student’s age.\nmajor: A string representing the student’s field of study.\ngraduated: A boolean indicating whether the student has graduated.\ncourses: An array of strings representing the courses the student has taken.\ndetails: A nested object with more specific information about the student’s GPA and credits completed.\n\n\n\nJSON Arrays\nIn JSON, arrays are used to store lists of data. An array can contain any type of value: numbers, strings, booleans, objects, or even other arrays. This makes JSON very flexible for representing complex data structures.\nExample of an array of student objects:\n[\n    {\n        \"name\": \"Alice\",\n        \"age\": 21,\n        \"major\": \"Statistics\"\n    },\n    {\n        \"name\": \"Bob\",\n        \"age\": 23,\n        \"major\": \"Mathematics\"\n    },\n    {\n        \"name\": \"Charlie\",\n        \"age\": 22,\n        \"major\": \"Computer Science\"\n    }\n]\nThis JSON array contains three objects, each representing a student with their name, age, and major.\n\n\n\n12.1.3 Differences Between JSON and Python Data Types\nAlthough JSON and Python share many similarities, there are important differences to keep in mind when converting between the two:\n\nPython dictionaries (dict) correspond to JSON objects.\nPython lists (list) correspond to JSON arrays.\nPython strings (str) map directly to JSON strings.\nPython integers and floats map to JSON numbers.\nPython None is equivalent to JSON null.\nPython True and False are equivalent to JSON true and false, respectively.\n\nThese mappings allow for seamless conversions between Python data structures and JSON, but developers must be aware of slight differences in how Python and JSON handle certain data. For example, in JSON, only double quotes (\") are allowed for strings, while Python allows both single and double quotes.\n\nExample: Converting Python Data to JSON\nSuppose you have the following Python dictionary:\n\nstudent_data = {\n    \"name\": \"Alice\",\n    \"age\": 21,\n    \"major\": \"Statistics\",\n    \"graduated\": False,\n    \"courses\": [\"Calculus\", \"Linear Algebra\", \"Statistics\"],\n    \"details\": {\n        \"GPA\": 3.8,\n        \"credits_completed\": 95\n    }\n}\n\nThis Python dictionary can be converted to JSON using the json module:\n\nimport json\n\njson_data = json.dumps(student_data)\nprint(json_data)\n\n{\"name\": \"Alice\", \"age\": 21, \"major\": \"Statistics\", \"graduated\": false, \"courses\": [\"Calculus\", \"Linear Algebra\", \"Statistics\"], \"details\": {\"GPA\": 3.8, \"credits_completed\": 95}}\n\n\nNote the subtle differences, such as the use of lowercase false instead of Python’s False, and the use of double quotes around strings.\n\n\n\n12.1.4 Use Cases for JSON\nJSON is widely used in various applications, some of the most common being:\n\nWeb APIs: JSON is the standard format for exchanging data between client-side applications (e.g., web browsers) and server-side applications.\nConfiguration Files: JSON is often used for configuration files in modern software applications because it is easy to read and write.\nData Serialization: JSON is commonly used to serialize and deserialize data in a format that can be easily exchanged across different programming languages and platforms.\nData Storage: JSON can be used as a lightweight alternative to databases for small-scale data storage, particularly for configuration settings or user preferences.\n\nBy understanding the structure of JSON and how it relates to Python’s data types, we can efficiently use it to handle data in real-world scenarios, particularly when working with web applications, APIs, or data storage systems."
  },
  {
    "objectID": "12_JSON.html#reading-and-writing-json-data",
    "href": "12_JSON.html#reading-and-writing-json-data",
    "title": "12  JSON Files in Python",
    "section": "12.2 Reading and Writing JSON Data",
    "text": "12.2 Reading and Writing JSON Data\nSerialization is the process of converting an object or data structure into a format that can be easily stored or transmitted and then reconstructed later. This process allows data to be saved to a file, sent over a network, or stored in a database, and later deserialized (reconstructed) back into its original form. In Python, serialization often refers to converting Python objects into formats like JSON, XML, or binary formats.\nFor example, when you serialize a Python dictionary into a JSON string, you are converting the dictionary into a format that can be written to a file or transmitted over a network. The reverse process—converting a serialized format back into a Python object—is called deserialization.\nOne of the key benefits of JSON in Python is the ease with which it can be read from and written to files using the built-in json module. This section explores the core methods provided by this module, including reading (parsing) JSON data from files, writing (serializing) Python objects into JSON, and handling JSON data as strings. Understanding these operations is essential for working with APIs, configurations, or any structured data exchange.\n\n12.2.1 Loading JSON Data from a File\nTo read (or deserialize) JSON data from a file, the json.load() method is used. This method reads the entire content of a file and converts it into a Python object (such as a dictionary or list). Here’s a simple example:\n\nExample: Reading from a JSON File\nAssume you have a file student.json that contains the following JSON data:\n{\n    \"name\": \"Alice\",\n    \"age\": 21,\n    \"major\": \"Statistics\",\n    \"graduated\": false\n}\nYou can load this data into a Python dictionary using the json.load() method as follows:\n\nimport json\n\n# Open the JSON file for reading\nwith open(\"student.json\", \"r\") as file:\n    student_data = json.load(file)\n\n# Accessing the data\nprint(student_data[\"name\"])  # Output: Alice\n\nAlice\n\n\nIn this example:\n\nWe open the student.json file in read mode.\nThe json.load() function parses the JSON data and converts it into a Python dictionary.\nYou can then access the values in the dictionary as you would with any Python dictionary.\n\n\n\n\n12.2.2 Error Handling While Loading JSON Data\nWhen reading JSON data from a file, errors can occur if the file is improperly formatted or does not exist. Python’s json module raises a json.JSONDecodeError if the content is not valid JSON, and a FileNotFoundError if the file is missing. To handle these potential errors, you can use try-except blocks.\nimport json\n\n# Safely loading JSON data from a file\ntry:\n    with open(\"student.json\", \"r\") as file:\n        student_data = json.load(file)\nexcept FileNotFoundError:\n    print(\"Error: The file was not found.\")\nexcept json.JSONDecodeError:\n    print(\"Error: The file contains invalid JSON.\")\nThis ensures that the program gracefully handles common file and parsing errors instead of crashing unexpectedly.\n\n\n12.2.3 Writing JSON Data to a File\nWriting (or serializing) Python objects into JSON format is done using the json.dump() method as shown in the previous section. This method takes a Python object and writes it to a file in JSON format.\n\nExample: Writing to a JSON File\nLet’s say we want to save a dictionary representing a student’s data to a JSON file:\nimport json\n\n# Python dictionary\nstudent_data = {\n    \"name\": \"Bob\",\n    \"age\": 23,\n    \"major\": \"Mathematics\",\n    \"graduated\": True\n}\n\n# Writing to a JSON file\nwith open(\"student.json\", \"w\") as file:\n    json.dump(student_data, file, indent=4)\nIn this example:\n\nWe open a file student.json in write mode.\nThe json.dump() function writes the student_data dictionary to the file in JSON format.\nThe indent=4 argument is used to format the output with indentation, making the JSON more readable.\n\nThe resulting student.json file will look like this:\n{\n    \"name\": \"Bob\",\n    \"age\": 23,\n    \"major\": \"Mathematics\",\n    \"graduated\": true\n}\n\n\n\n12.2.4 Error Handling When Writing JSON Data\nJust like reading JSON files, writing to JSON files can also result in errors, such as IOError if the file cannot be opened or written to. To handle these cases, wrap the json.dump() operation in a try-except block.\nimport json\n\n# Safely writing JSON data to a file\ntry:\n    with open(\"student.json\", \"w\") as file:\n        json.dump(student_data, file, indent=4)\nexcept IOError as e:\n    print(f\"Error writing to file: {e}\")\nThis approach ensures that your program responds appropriately if file operations fail.\n\n\n12.2.5 Loading JSON Data from a String\nIn some cases, JSON data might not come from a file but from a string, such as when receiving data from a web API. The json.loads() function is used to parse JSON data from a string and convert it into a Python object.\n\nExample: Parsing JSON from a String\nHere’s how you can parse a JSON string into a Python dictionary:\n\nimport json\n\n# JSON string\njson_string = '{\"name\": \"Charlie\", \"age\": 22, \"major\": \"Computer Science\"}'\n\n# Parsing the JSON string\nstudent_data = json.loads(json_string)\n\nprint(student_data)  # Output: {'name': 'Charlie', 'age': 22, 'major': 'Computer Science'}\n\n{'name': 'Charlie', 'age': 22, 'major': 'Computer Science'}\n\n\nThe json.loads() method converts the JSON string into a Python dictionary, which can be used like any other dictionary.\n\n\n\n12.2.6 Converting Python Objects to JSON Strings\nIn addition to writing JSON to files, you might need to generate JSON-formatted strings for data exchange, such as sending data over a network or printing it to the console. The json.dumps() function allows you to convert Python objects to JSON strings.\n\nExample: Converting Python Dictionary to JSON String\n\nimport json\n\n# Python dictionary\nstudent_data = {\n    \"name\": \"Diana\",\n    \"age\": 20,\n    \"major\": \"Engineering\"\n}\n\n# Converting to JSON string\njson_string = json.dumps(student_data, indent=4)\nprint(json_string)\n\n{\n    \"name\": \"Diana\",\n    \"age\": 20,\n    \"major\": \"Engineering\"\n}\n\n\nThe indent parameter is optional, but it improves readability by formatting the JSON with proper indentation.\n\n\n\n12.2.7 Customizing JSON Serialization\nSometimes, Python objects may contain data types that are not directly serializable by the json module, such as datetime objects. In these cases, you can provide a custom function to handle the serialization of these complex types.\n\nExample: Custom Serialization\n\nimport json\nfrom datetime import datetime\n\n# Python dictionary with a datetime object\nstudent_data = {\n    \"name\": \"Emily\",\n    \"graduation_date\": datetime(2023, 5, 15)\n}\n\n# Custom serialization function\ndef custom_serializer(obj):\n    if isinstance(obj, datetime):\n        return obj.strftime('%Y-%m-%d')\n    raise TypeError(f\"Type {type(obj)} is not serializable\")\n\n# Converting to JSON string with custom serialization\njson_string = json.dumps(student_data, default=custom_serializer, indent=4)\nprint(json_string)\n\n{\n    \"name\": \"Emily\",\n    \"graduation_date\": \"2023-05-15\"\n}\n\n\nIn this example, the default parameter is used to specify a custom serialization function for handling the datetime object. The resulting JSON string will look like this:\nWithout the custom function, attempting to serialize a datetime object would raise a TypeError."
  },
  {
    "objectID": "12_JSON.html#exercises",
    "href": "12_JSON.html#exercises",
    "title": "12  JSON Files in Python",
    "section": "12.3 Exercises",
    "text": "12.3 Exercises\n\nExercise 1: Loading JSON from a File\nYou have a file named book.json that contains the following JSON data:\n{\n    \"title\": \"Python Programming\",\n    \"author\": \"John Doe\",\n    \"year\": 2020,\n    \"genres\": [\"Programming\", \"Technology\"],\n    \"available\": true\n}\nA. Write a Python program to read the contents of the file book.json and print the title of the book. B. Extend your program to print the author and the list of genres as well.\n\n\nExercise 2: Writing JSON to a File\nCreate a Python dictionary that represents the following student data:\n\nName: “Sarah”\nAge: 24\nMajor: “Data Science”\nCourses: [“Machine Learning”, “Statistics”, “Python Programming”]\nGraduated: False\n\nA. Write a Python script that saves this dictionary to a file named student_data.json in JSON format with indentation. B. Open the file and verify that the content is properly formatted as JSON.\n\n\nExercise 3: Parsing JSON from a String\nYou receive the following JSON string from an API response:\n{\n    \"city\": \"Austin\",\n    \"temperature\": 30,\n    \"conditions\": \"Sunny\",\n    \"forecast\": [\"Sunny\", \"Partly Cloudy\", \"Rain\"]\n}\nA. Write a Python program to parse this JSON string and convert it into a Python dictionary. B. Print the current weather condition (\"conditions\") and the second item in the forecast list.\n\n\nExercise 4: Serializing Python Data to JSON\nYou are given the following Python dictionary:\nemployee_data = {\n    \"name\": \"Alice\",\n    \"id\": 12345,\n    \"position\": \"Software Engineer\",\n    \"start_date\": \"2021-09-01\",\n    \"salary\": 85000,\n    \"active\": True\n}\nA. Write a Python script to convert this dictionary into a JSON-formatted string. B. Ensure that the resulting JSON string is printed with an indentation of 4 spaces for better readability. C. Save this JSON string to a file called employee.json.\n\n\nExercise 5: Handling Errors in JSON Files\nYou are working with JSON files, and sometimes they may not be formatted correctly or may be missing. Write a Python program that:\nA. Attempts to load JSON data from a file named config.json. B. If the file is missing or contains invalid JSON, catch and handle the exceptions appropriately, printing an error message like:\n\n\"Error: config.json not found.\" for missing files.\n\"Error: Invalid JSON format.\" for JSON decoding errors.\n\n\n\nExercise 6: Custom Serialization of Python Objects\nConsider a Python dictionary that contains a datetime object:\nfrom datetime import datetime\n\nevent = {\n    \"name\": \"Conference\",\n    \"location\": \"New York\",\n    \"date\": datetime(2024, 5, 15, 10, 30)\n}\nA. Write a Python program to serialize this dictionary into a JSON string. Use a custom serialization function to convert the datetime object into a string formatted as YYYY-MM-DD HH:MM. B. Save the resulting JSON string to a file named event.json.\n\n\nExercise 7: Converting a List of Dictionaries to JSON\nYou have the following list of dictionaries, each representing a book in a library:\nbooks = [\n    {\"title\": \"Python Basics\", \"author\": \"Alice\", \"year\": 2019},\n    {\"title\": \"Data Science Handbook\", \"author\": \"Bob\", \"year\": 2021},\n    {\"title\": \"Machine Learning 101\", \"author\": \"Charlie\", \"year\": 2020}\n]\nA. Write a Python script to convert this list into a JSON-formatted string. B. Save the JSON data to a file called books.json.\n\n\nExercise 8: Modifying and Writing JSON Data\nYou are given a file named users.json with the following data:\n[\n    {\"username\": \"john_doe\", \"email\": \"john@example.com\", \"active\": true},\n    {\"username\": \"jane_doe\", \"email\": \"jane@example.com\", \"active\": false}\n]\nA. Write a Python script that loads this data into a Python list. B. Modify the script to activate all users by setting the \"active\" field to true for all entries. C. Save the modified data back to users.json.\n\n\nExercise 9: Nested JSON Parsing\nYou are given a JSON string representing nested product data:\n{\n    \"product\": {\n        \"id\": 101,\n        \"name\": \"Laptop\",\n        \"price\": 1200,\n        \"specifications\": {\n            \"processor\": \"Intel i7\",\n            \"ram\": \"16GB\",\n            \"storage\": \"512GB SSD\"\n        }\n    }\n}\nA. Write a Python program to parse this JSON string into a Python dictionary. B. Extract and print the product name, price, and the processor specification from the nested dictionary."
  }
]