[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "STA 2450 Computing for Math & Stat",
    "section": "",
    "text": "Introduction\nThese are the lecture notes for STA 2450 - Computing for Math & Stat.\nPrerequisites: None\n\nCourse Description:\nComputer programming for mathematical scientists with emphasis on designing algorithms, problem solving, and coding practices. Topics include development of programs from specifications; appropriate use of data types; functions; modular program organization; documentation and style; and version control and collaborative programming."
  },
  {
    "objectID": "01_Intro_to_Programming.html#algorithms-on-computers",
    "href": "01_Intro_to_Programming.html#algorithms-on-computers",
    "title": "1  An Intro to Computing",
    "section": "1.1 Algorithms on Computers",
    "text": "1.1 Algorithms on Computers\nOne way to illustrate the concept of a recipe in a mechanical process is by designing machines specifically intended to solve certain problems. The earliest computers were fixed-program computers, meaning they were designed to solve a specific mathematical problem. Some simple computers still use this approach. For example, a four-function calculator can perform basic arithmetic but is not designed for word processing or gaming. Users cannot change their programs without replacing internal components.\nThe first modern computer to run a program was the Manchester Mark 1 in 1949. Unlike its predecessors, it was a stored-program computer. These machines store sequences of instructions that can be executed by an interpreter. This interpreter can execute any legal set of instructions, enabling it to compute anything that can be described using those instructions. The program and the data it manipulates reside in memory.\nTypically, a program counter points to a specific location in memory, and computation starts by executing the instruction at that point. Most often, the interpreter simply proceeds to the next instruction in the sequence. However, in some cases, it performs a test, and based on that test, execution may jump to another point in the sequence of instructions."
  },
  {
    "objectID": "01_Intro_to_Programming.html#programming-languages",
    "href": "01_Intro_to_Programming.html#programming-languages",
    "title": "1  An Intro to Computing",
    "section": "1.2 Programming Languages",
    "text": "1.2 Programming Languages\nTo use execute algorithms on a computer, we need a programming language to describe the sequence of instructions. The British mathematician Alan Turing devised a theoretical device in 1936 known as the Universal Turing Machine. This hypothetical computer had unlimited memory, represented by a tape on which one could write zeroes and ones. It also consisted of simple instructions for moving, reading, and writing on the tape.\nThe Church-Turing thesis posits that if a function is computable, a Turing Machine can be programmed to compute it. The “if” in the Church-Turing thesis is crucial because not all problems have computational solutions.\n\n\n\n\n\n\nNote\n\n\n\nA function or problem is considered computable if there exists a finite sequence of well-defined steps, an algorithm, that can be implemented by a computational model (such as a Turing Machine) to produce the correct output for any valid input within a finite amount of time. In other words, a problem is computable if there is a systematic method to solve it using an algorithm.\n\n\nThe Church-Turing thesis leads directly to the concept of Turing completeness. A programming language is said to be Turing complete if it can simulate a universal Turing Machine. All modern programming languages are Turing complete, meaning that anything that can be programmed in one language (e.g., Python) can also be programmed in another language (e.g., Java). While certain tasks may be easier to program in specific languages, all languages are fundamentally equal in terms of computational power."
  },
  {
    "objectID": "01_Intro_to_Programming.html#types-of-programming-languages",
    "href": "01_Intro_to_Programming.html#types-of-programming-languages",
    "title": "1  An Intro to Computing",
    "section": "1.3 Types of Programming Languages",
    "text": "1.3 Types of Programming Languages\n\n1.3.1 Low-Level vs. High-Level Languages\nLow-level languages are closer to machine language, providing little to no abstraction from a computer’s hardware. They allow direct control over the hardware and memory, making them highly efficient but also more complex to write and understand. Examples of low-level languages include Assembly language and machine code.\nLow-level languages operate with minimal abstraction which results in high-performance programs that execute faster and are more efficient in resource usage. However, this comes with the trade-off of complex and less intuitive code, requiring a deep understanding of computer architecture. Additionally, low-level programs are often platform-specific, meaning they are tailored to a particular type of processor or computer architecture.\n\nExample: Assembly Language\nMOV AX, 1   ; Move the value 1 into the AX register\nADD AX, 2   ; Add the value 2 to the AX register\nMOV BX, AX  ; Move the result from AX to BX\nHigh-level languages abstract away the details of computer hardware, allowing programmers to focus on the logic of the problem rather than the intricacies of the machine. They feature more intuitive syntax and semantics, making them easier to learn and use. Programs written in high-level languages are generally portable across different platforms with minimal modification. These languages also come with extensive libraries and frameworks that simplify complex tasks such as GUI development, web programming, and data manipulation. Although this abstraction can result in slower execution compared to low-level languages, the trade-off is often worth it for the ease of development and maintenance.\n\n\nExample: Print a greeting to the screen in Python\nprint(\"Hello, World!\")  \nLow-level languages offer greater control over hardware and performance optimization, whereas high-level languages prioritize ease of use and development speed. This means that while low-level languages generally result in faster and more efficient programs, they come at the cost of greater complexity. In contrast, high-level languages, although potentially slower, provide significant productivity benefits. Their readability and maintainability make them suitable for large-scale applications and collaborative projects. Additionally, high-level languages reduce development time due to their simplicity and the availability of powerful libraries and frameworks.\nUnderstanding the trade-offs between low-level and high-level languages is crucial for selecting the right tool for a given task. For most applications, high-level languages provide sufficient performance while dramatically simplifying development. However, for performance-critical applications, such as operating system kernels or embedded systems, low-level languages remain indispensable.\n\n\n\n1.3.2 General-Purpose vs. Domain-Specific Languages\nGeneral-purpose programming languages are highly versatile, allowing them to be used for a wide array of programming tasks, including web development, data analysis, game development, and more. They come with extensive standard libraries and frameworks that support diverse functionalities, making it easier to implement complex features. Programs written in these languages are often portable across different operating systems and platforms. Additionally, these languages usually have large communities, extensive documentation, and abundant resources for learning and troubleshooting. Examples of well-known general-purpose programming languages include Python, Java, C++, and JavaScript.\nDomain-specific Domain-specific languages (DSLs) are designed to handle specific types of tasks, offering features and abstractions directly relevant to their domain. They often allow for more concise and efficient coding within their domain, reducing the complexity and effort required to develop certain applications. However, their functionality is typically narrow, focusing on particular problem areas and lacking the versatility of general-purpose languages. Examples of well-known domain-specific languages include SQL, HTML, and MATLAB.\nGeneral-purpose languages are suitable for a wide variety of applications, providing greater flexibility and usability across many contexts. In contrast, domain-specific languages are specialized for particular tasks, making them more efficient and easier to use within their specific domains. While general-purpose languages often require learning a broader set of concepts and syntax, domain-specific languages might have a steeper but narrower learning curve focused on their particular use case.\n\n\n1.3.3 Interpreted vs. Compiled Languages\nInterpreted languages execute code directly through an interpreter, which translates high-level instructions into machine code line by line. This immediate execution provides several advantages, such as ease of debugging, as interpreted languages often generate more informative error messages, making it simpler to identify and correct issues by pointing to the exact line where an error occurred. Additionally, interpreted languages offer platform independence, allowing the same source code to run on any platform with a compatible interpreter, enhancing portability. However, interpreted programs generally run slower than compiled programs because the translation occurs at runtime. Well-known interpreted languages include Python, JavaScript, Ruby, and PHP.\nCompiled languages require the source code to be translated into machine code by a compiler before execution, producing an executable file. This pre-execution compilation results in faster execution, as the translation is completed beforehand, allowing the executable file to be directly executed by the hardware. Compilers also perform extensive checks during compilation, catching many types of errors before the program runs. However, compiled executables are specific to the target platform’s architecture, making them less portable unless recompiled for different platforms. Well-known compiled languages include C, C++, Rust, and Go.\n\nExample of C Code:\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}\nThis C code must be compiled into an executable file before it can be run.\nCompiled languages generally produce faster-running programs since the code is translated into machine language ahead of time, whereas interpreted languages tend to be slower due to on-the-fly translation. However, interpreted languages offer a quicker development cycle, allowing code to be written and tested immediately without a separate compilation step, which is advantageous for rapid prototyping and iterative development. Interpreted languages also boast better portability, as the same code can run on any platform with the appropriate interpreter, while compiled languages require recompilation for different platforms, adding complexity.\nDebugging is typically easier with interpreted languages because they provide more immediate and informative error feedback, pointing directly to issues in the source code. Although compiled languages catch many errors at compile time, their runtime error messages can be less detailed. Additionally, interpreted languages can support more dynamic programming features, such as dynamic typing and runtime evaluation of code, which can be more challenging to implement efficiently in compiled languages."
  },
  {
    "objectID": "01_Intro_to_Programming.html#intro-to-python",
    "href": "01_Intro_to_Programming.html#intro-to-python",
    "title": "1  An Intro to Computing",
    "section": "1.4 Intro to Python",
    "text": "1.4 Intro to Python\nIn this course, we will be using Python. Python is a general-purpose programming language that can be used to build almost any kind of program that does not require direct access to the computer’s hardware. However, Python is not optimal for programs with high reliability constraints or those that are built and maintained by many people over a long period.\nPython has several advantages over many other languages. It is relatively simple and easy to learn. Because Python is designed to be interpreted, it provides runtime feedback that is especially helpful for novice programmers.\nPython was first developed by Guido van Rossum in 1990. It went largely unnoticed during its first decade but gained popularity around 2000 with the release of Python 2.0. Python 3.0, released at the end of 2008, cleaned up many inconsistencies in Python 2’s design. While Python 3.0 is not backward-compatible with earlier versions, most important public domain libraries have been ported over, eliminating the need to use outdated software."
  },
  {
    "objectID": "02_Python_Install.html#installing-python",
    "href": "02_Python_Install.html#installing-python",
    "title": "2  Installing Python and Setting Up Your IDE",
    "section": "2.1 Installing Python",
    "text": "2.1 Installing Python\nTo start programming in Python, you’ll first need to install Python on your computer. Follow the instructions below based on your operating system:\nWindows:\n\nGo to the official Python website: python.org.\nClick on the “Downloads” tab.\nDownload the latest version of Python (ensure it’s a stable release).\nRun the installer and make sure to check the box that says “Add Python to PATH”.\nFollow the installation prompts.\n\nmacOS:\n\nOpen Terminal.\nUse Homebrew to install Python (if you don’t have Homebrew, you can install it from brew.sh):\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nInstall Python:\nbrew install python\n\nLinux:\n\nOpen Terminal.\nUse your package manager to install Python. For Debian-based systems like Ubuntu:\nsudo apt update\nsudo apt install python3\nFor Red Hat-based systems like Fedora:\nsudo dnf install python3\n\nTo verify the installation, open your terminal or command prompt and type:\npython --version\nYou should see the installed Python version displayed."
  },
  {
    "objectID": "02_Python_Install.html#understanding-integrated-development-environments-ides",
    "href": "02_Python_Install.html#understanding-integrated-development-environments-ides",
    "title": "2  Installing Python and Setting Up Your IDE",
    "section": "2.2 Understanding Integrated Development Environments (IDEs)",
    "text": "2.2 Understanding Integrated Development Environments (IDEs)\n\nWhat is an IDE?\nAn Integrated Development Environment (IDE) is a software application that provides comprehensive facilities to programmers for software development. An IDE typically includes:\n\nSource Code Editor: A text editor that supports code writing with features like syntax highlighting, auto-completion, and error detection.\nBuild Automation Tools: Tools that automate tasks like compiling code, packaging files, and running tests.\nDebugger: A tool that helps you test and debug your code by allowing you to step through your code, set breakpoints, and inspect variables.\n\nIDEs are designed to make the process of coding easier and more efficient by combining all the tools you need into a single application.\n\n\nBenefits of Using an IDE\nUsing an IDE offers numerous benefits and features that enhance the coding process. An IDE can significantly speed up development by providing quick access to all necessary tools, enhancing efficiency. Features like syntax highlighting and error detection help catch mistakes early, reducing the amount of debugging needed, thereby improving error reduction.\nThe convenience of having everything in one place makes it easier to manage projects, especially as they grow in size and complexity. Additionally, many IDEs include tools for version control, making it easier to track changes and collaborate with others, thus improving code management.\nKey features of an IDE streamline the coding process further. Syntax highlighting colors keywords, variables, and syntax, making the code more readable and easier to debug. Auto-completion suggests code completions as you type, helping to write code faster and avoid typos. Code navigation allows you to quickly jump to definitions, references, and files within your project. The integrated debugger lets you run your code step by step, inspect variables, and identify issues.\n\n\nPopular Python IDEs\n\nPyCharm: A powerful IDE specifically for Python development, offering advanced features and professional tools.\nRStudio: Primarily used for R programming but also supports Python, providing a familiar interface for those who use both languages.\nVisual Studio Code: A versatile code editor with extensive Python support through extensions, combining lightweight design with powerful features.\n\n\n\nChoosing an IDE\nChoosing the right IDE depends on your needs and preferences. Some factors to consider include ease of use, which refers to how intuitive and user-friendly the IDE is, and the feature set, which involves the availability of features that match your development needs. Performance is also crucial, particularly how well the IDE performs with larger projects. Additionally, consider the community and support available, including documentation, tutorials, and community support.\nWhether you use PyCharm, RStudio, or another IDE, having a good development environment can make a significant difference in your productivity and the quality of your code. A well-chosen IDE enhances your coding experience, making it easier to write, manage, and debug your projects efficiently."
  },
  {
    "objectID": "02_Python_Install.html#setting-up-your-ide",
    "href": "02_Python_Install.html#setting-up-your-ide",
    "title": "2  Installing Python and Setting Up Your IDE",
    "section": "2.3 Setting Up Your IDE",
    "text": "2.3 Setting Up Your IDE\nUsing PyCharm:\nPyCharm, developed by JetBrains, is a popular IDE specifically designed for Python programming. JetBrains, a software development company based in Prague, Czech Republic, was founded in 2000 and has since become renowned for creating intelligent, productivity-enhancing tools for software developers. The journey of PyCharm began in 2010, when JetBrains identified the need for a dedicated, feature-rich IDE for Python developers. At that time, Python was gaining significant traction due to its simplicity and versatility, and there was a growing demand for an IDE that could cater specifically to Python’s unique requirements.\nJetBrains leveraged its extensive experience in creating IDEs, such as IntelliJ IDEA for Java, to develop PyCharm. They aimed to build an IDE that would not only support the standard features expected by developers, such as code completion and debugging, but also include advanced capabilities like scientific computing support, web development frameworks, and robust version control integration. PyCharm quickly became popular within the Python community for its powerful features, intuitive user interface, and the comprehensive support it provided for various Python frameworks and libraries. Over the years, PyCharm has continued to evolve, incorporating feedback from its user base and keeping pace with the latest advancements in Python development.\nHere’s how to set up PyCharm:\n\nDownload and Install PyCharm:\n\nGo to the JetBrains website: jetbrains.com/pycharm/download.\nChoose the Community edition (it’s free).\nFollow the installation instructions for your operating system.\n\nConfiguring PyCharm:\n\nOpen PyCharm.\nSelect “New Project”.\nChoose a location for your project.\nEnsure the Python interpreter is set correctly. If Python is not listed, click on “Existing interpreter” and locate your Python installation.\nClick “Create”.\n\nWriting Your First Program:\n\nRight-click on your project folder in the Project pane.\nSelect “New” &gt; “Python File”.\nName your file (e.g., hello_world.py).\nType the following code:\nprint(\"Hello, world!\")\nRight-click on the file and select “Run” to execute your code.\n\n\nUsing RStudio:\nRStudio, developed by RStudio, PBC, is a comprehensive IDE primarily designed for the R programming language. The inception of RStudio dates back to 2008, when its founders, including JJ Allaire, sought to create a powerful tool to support the growing community of R users. R, a language and environment for statistical computing and graphics, was gaining popularity among statisticians and data scientists due to its robust capabilities for data analysis and visualization. However, the available development tools for R at that time were limited, and there was a clear need for a more sophisticated and user-friendly IDE.\nJJ Allaire, already an experienced software developer known for creating the ColdFusion web development platform, aimed to fill this gap by developing RStudio. The initial release of RStudio in 2011 was met with enthusiasm from the R community. It offered a user-friendly interface, integrating essential features like a source code editor, console, workspace, and graphics viewer within a single window. This made it significantly easier for users to write, debug, and visualize their R code.\nOver the years, RStudio has expanded its functionality to support not only R but also other programming languages like Python, enhancing its utility for data scientists and statisticians. The open-source nature of RStudio and its commitment to the R community have contributed to its widespread adoption. Today, RStudio is a central tool in data science, used by individuals and organizations worldwide for data analysis, research, and reporting.\nHere’s how to set up RStudio:\n\nDownload and Install RStudio:\n\nGo to the RStudio website: rstudio.com.\nDownload the free version for your operating system.\nFollow the installation instructions.\n\nConfiguring RStudio for Python:\n\nOpen RStudio.\nGo to “Tools” &gt; “Global Options”.\nSelect “Python” from the menu on the left.\nSet the Python interpreter to your installed Python version (e.g., /usr/bin/python3 or C:\\Python39\\python.exe).\n\nWriting Your First Program:\n\nGo to “File” &gt; “New File” &gt; “Python Script”.\nType the following code:\nprint(\"Hello, world!\")\nSave the file with a .py extension (e.g., hello_world.py).\nClick the “Run” button to execute your code.\n\n\nBy following these instructions, you’ll have Python installed and be ready to start coding with PyCharm or RStudio as your IDE."
  },
  {
    "objectID": "03_Basic_Syntax_and_Expressions.html#syntax-in-programming-languages",
    "href": "03_Basic_Syntax_and_Expressions.html#syntax-in-programming-languages",
    "title": "3  Basic Syntax and Expressions",
    "section": "3.1 Syntax in Programming Languages",
    "text": "3.1 Syntax in Programming Languages\nSyntax rules in programming languages define how the code should be written and structured. These rules ensure that the code is readable both by humans and by the computer. Just as syntax in a spoken language dictates how words and phrases should be combined to convey meaning, syntax in programming languages dictates how symbols and keywords can be combined to create valid instructions.\nKey elements of syntax include keywords, operators, punctuation, and the overall structure of statements.\n\nKeywords\nKeywords are reserved words that have special meanings in a programming language. For example, in English, words like “and,” “or,” “if,” and “then” are used to connect ideas and indicate logical relationships. Similarly, in Python, keywords like if, else, while, for, and def are used to construct control flow and define functions.\nExample in English: - “If it rains, then bring an umbrella.”\nExample in Python:\nif it_rains:\n    bring_umbrella()\n\n\nOperators\nOperators are symbols that perform operations on values. In both English and programming languages, operators are used to combine or modify elements.\nExample in English: - “Three plus five equals eight.”\nExample in Python:\n3 + 5\n\n\nPunctuation\nPunctuation marks, such as periods, commas, and parentheses, are used to group and organize sentences in English. Similarly, in programming languages, punctuation marks like parentheses (), brackets [], and braces {} are used to group and organize code.\nExample in English: - “He said, ‘Hello!’”\nExample in Python:\nprint(\"Hello!\")\n\n\nStatements and Expressions\nA statement is an instruction that the Python interpreter can execute, while an expression is a combination of values, variables, and operators that can be evaluated to produce another value. Every expression is a statement, but not every statement is an expression.\nExample in English: - “The sum of three and five is eight.” (Expression: “Three plus five”)\nExample in Python:\n3 + 5  # Expression\nprint(3 + 5)  # Statement\n\n\n\n\n\n\nNote\n\n\n\nComments in Python code are denoted by the # symbol and are used to explain and document the code. They are ignored by the Python interpreter and do not affect the execution of the program, making them useful for enhancing code readability and providing context for developers.\n\n\nUnderstanding the syntax rules in both natural and programming languages is crucial for effective communication and problem-solving. Syntax ensures that our messages, whether written in English or Python, are clear and interpretable by others, including computers."
  },
  {
    "objectID": "03_Basic_Syntax_and_Expressions.html#semantics-in-programming-languages",
    "href": "03_Basic_Syntax_and_Expressions.html#semantics-in-programming-languages",
    "title": "3  Basic Syntax and Expressions",
    "section": "3.2 Semantics in Programming Languages",
    "text": "3.2 Semantics in Programming Languages\nSemantics concerns the meaning of syntactically correct strings of symbols. In other words, while syntax is about the form, semantics is about the function. Semantics ensure that a piece of code not only adheres to the rules of the language but also performs the intended operations.\nFor instance, the expression 3 + 4 adheres to Python’s syntax rules and its semantics dictate that this expression will evaluate to 7.\nTo illustrate basic syntax and semantics, let’s look at some simple Python expressions.\n\nExample 1: Arithmetic Operations\nArithmetic operations in Python are straightforward and follow standard mathematical conventions.\n# Adding two numbers\n3 + 5\n\n# Subtracting two numbers\n10 - 4\n\n# Multiplying two numbers\n7 * 6\n\n# Dividing two numbers\n8 / 2\nEach of these expressions follows the syntax rules for arithmetic operators in Python and has clear semantics: they perform addition, subtraction, multiplication, and division, respectively.\n\n\nExample 2: Comparison Operations\nComparison operations are used to compare values and produce Boolean results (True or False).\n# Checking equality\n4 == 4\n\n# Checking inequality\n5 != 3\n\n# Checking greater than\n9 &gt; 7\n\n# Checking less than\n2 &lt; 6\nThese expressions compare two values and return a Boolean value based on the comparison.\n\n\nExample 3: Logical Operations\nLogical operations combine Boolean values and are useful in conditional expressions.\n# Logical AND\nTrue and False\n\n# Logical OR\nTrue or False\n\n# Logical NOT\nnot True\nIn these examples, logical operators evaluate the Boolean expressions and return a Boolean result.\nUnderstanding the basic syntax and semantics of a programming language is crucial for writing correct and efficient code. Syntax provides the structure, while semantics ensures that the code performs the intended operations."
  },
  {
    "objectID": "04_Names_and_Variables.html#sec-names",
    "href": "04_Names_and_Variables.html#sec-names",
    "title": "4  Names and Variables",
    "section": "4.1 Names",
    "text": "4.1 Names\nNames in programming are identifiers used to label and reference entities such as variables, functions, classes, and modules. They serve as a means to access stored data and functionality, making code more readable and maintainable. For instance, instead of repeatedly using a complex expression or value, we can assign it a name and refer to it using that name.\n\n4.1.1 Rules for Naming\nIn Python, there are specific rules and conventions for naming identifiers:\n\nAlphabetic Characters and Underscores: Names must begin with a letter (a-z, A-Z) or an underscore (_), followed by letters, digits (0-9), or underscores.\nCase Sensitivity: Names are case-sensitive, meaning Variable, variable, and VARIABLE are distinct identifiers.\nReserved Keywords: Names cannot be Python reserved keywords, such as if, else, for, while, class, def, etc."
  },
  {
    "objectID": "04_Names_and_Variables.html#variables",
    "href": "04_Names_and_Variables.html#variables",
    "title": "4  Names and Variables",
    "section": "4.2 Variables",
    "text": "4.2 Variables\nVariables are names assigned to data values stored in memory. They act as containers holding information that can be manipulated and accessed throughout a program. Variables allow for dynamic and flexible data handling, making it possible to perform computations, store results, and manage state.\n\nVariable Assignment\nIn Python, variable assignment is straightforward. Use the assignment operator (=) to assign a value to a variable:\nx = 10\nname = \"Alice\"\nis_student = True\n\n\nVariable Scope\nThe scope of a variable determines its accessibility within different parts of a program. There are two primary types of scope in Python:\n\nGlobal Scope: Variables defined outside any function (functions will be discussed in Chapter 8) or block have global scope and can be accessed anywhere in the program.\nLocal Scope: Variables defined within a function or block have local scope and can only be accessed within that function or block.\n\nglobal_var = \"I am global\"\n\ndef my_function():\n    local_var = \"I am local\"\n    print(global_var)  # Accessible\n    print(local_var)  # Accessible\n\nmy_function()\nprint(global_var)  # Accessible\nprint(local_var)  # Error: NameError\n\n\nConstants\nConstants are variables whose values are intended to remain unchanged throughout the program. While Python does not have built-in constant types, by convention, we use all uppercase letters to indicate constants:\nPI = 3.14159\nMAX_STUDENTS = 50\n\n\n4.2.1 Examples and Applications\nTo solidify our understanding of names and variables, let’s explore some practical examples and applications:\n\nExample: Simple Calculator\n# Simple Calculator Program\nnum1 = 10\nnum2 = 5\n\n# Performing arithmetic operations\nsum_result = num1 + num2\ndifference = num1 - num2\nproduct = num1 * num2\nquotient = num1 / num2\n\nprint(\"Sum:\", sum_result)\nprint(\"Difference:\", difference)\nprint(\"Product:\", product)\nprint(\"Quotient:\", quotient)\n\n\nExample: Temperature Conversion\n# Temperature Conversion Program (Celsius to Fahrenheit)\ncelsius = 25\nfahrenheit = (celsius * 9/5) + 32\n\nprint(celsius, \"Celsius is\", fahrenheit, \"Fahrenheit\")\nUnderstanding names and variables is crucial for effective programming. Names provide a way to reference and access data, while variables store the data we work with. By adhering to naming conventions and understanding variable scope and types, we can write clearer, more maintainable code. As we progress, these fundamental concepts will underpin more complex programming tasks and techniques."
  },
  {
    "objectID": "04_Names_and_Variables.html#exercises",
    "href": "04_Names_and_Variables.html#exercises",
    "title": "4  Names and Variables",
    "section": "4.3 Exercises",
    "text": "4.3 Exercises\n\nExercise 1: Variable Assignment\n\nAssign the value 50 to a variable named my_age and use print to display the variable.\nAssign the string \"Hello, Python!\" to a variable named greeting and use print to display the variable.\nAssign the boolean value False to a variable named is_raining and use print to display the variable.\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 2: Variable Reassignment\n\nAssign the value 10 to a variable named number and use print to display the variable.\nReassign the value of number to 20 and use print to display the variable.\nReassign the value of number to the string \"twenty\" and use print to display the variable.\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 3: Basic Arithmetic\n\nCreate two variables a and b, and assign them the values 8 and 3 respectively.\nPerform the following operations and print the results:\n\nSum of a and b\nDifference between a and b\nProduct of a and b\nQuotient of a divided by b\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 4: Temperature Conversion\n\nCreate a variable fahrenheit and assign it the value 86.\nConvert the temperature to Fahrenheit using the formula: celsius = (fahrenheit - 32) * 5/9.\nPrint the Celsius value.\n\n\n\n\n\n\n\n\n\nExercise 5: Constants\n\nDefine a constant PI with the value 3.14159.\nDefine a constant MAX_SPEED with the value 120.\nPrint both constants."
  },
  {
    "objectID": "05_Data_Types.html#common-data-types-in-python",
    "href": "05_Data_Types.html#common-data-types-in-python",
    "title": "5  Data Types",
    "section": "5.1 Common Data Types in Python",
    "text": "5.1 Common Data Types in Python\nPython supports various built-in data types, each suited for different kinds of operations and uses. The primary data types include:\n\nInteger (int)\nFloat (float)\nString (str)\nBoolean (bool)\nNoneType (None)\n\nWe will discuss each of these types in detail.\n\n5.1.1 Integer (int)\nAn integer is a whole number, positive or negative, without decimals, of unlimited length. In Python, integers are of type int.\nExample:\n\na = 10\nb = -5\nc = 123456789\n\nTo check the type of a variable, use the type() function:\n\nprint(type(a))  \nprint(type(b))\n\n&lt;class 'int'&gt;\n&lt;class 'int'&gt;\n\n\n\n\n5.1.2 Float (float)\nA float, or floating-point number, is a number that has a decimal place. Python uses the float type to represent these numbers.\nExample:\n\nx = 10.5\ny = -3.14\nz = 1.0\n\nChecking the type of a float variable:\n\nprint(type(x))\nprint(type(y))\n\n&lt;class 'float'&gt;\n&lt;class 'float'&gt;\n\n\n\n\n5.1.3 String (str)\nA string is a sequence of characters enclosed in quotes. Strings can be enclosed in single quotes ('), double quotes (\"), or triple quotes (''' or \"\"\").\nExample:\n\nname = \"Alice\"\ngreeting = 'Hello, World!'\nparagraph = \"\"\"This is a\nmultiline string.\"\"\"\n\nTo determine if a variable is a string:\n\nprint(type(name)) \n\n&lt;class 'str'&gt;\n\n\n\n\n5.1.4 Boolean (bool)\nBooleans represent one of two values: True or False. They are commonly used in conditional statements and comparisons.\nExample:\n\nis_student = True\nis_raining = False\n\nChecking the type of a boolean variable:\n\nprint(type(is_student)) \n\n&lt;class 'bool'&gt;\n\n\n\n\n5.1.5 NoneType (None)\nNone is a special data type in Python that represents the absence of a value. It is an object of its own datatype, the NoneType.\nExample:\n\nunknown = None\n\nTo check if a variable is of NoneType:\n\nprint(type(unknown))\n\n&lt;class 'NoneType'&gt;"
  },
  {
    "objectID": "05_Data_Types.html#dynamic-typing-in-python",
    "href": "05_Data_Types.html#dynamic-typing-in-python",
    "title": "5  Data Types",
    "section": "5.2 Dynamic Typing in Python",
    "text": "5.2 Dynamic Typing in Python\nPython is a dynamically typed language, which means you do not need to declare the type of a variable when you create one. The type is determined at runtime based on the value assigned to it.\nExample:\n\nvariable = 5\nprint(type(variable)) \n\nvariable = \"Hello\"\nprint(type(variable)) \n\n&lt;class 'int'&gt;\n&lt;class 'str'&gt;\n\n\nThis feature provides flexibility but requires careful handling to avoid type-related errors."
  },
  {
    "objectID": "05_Data_Types.html#type-conversion",
    "href": "05_Data_Types.html#type-conversion",
    "title": "5  Data Types",
    "section": "5.3 Type Conversion",
    "text": "5.3 Type Conversion\nSometimes, you may need to convert values from one type to another. This is known as type casting. Python provides several built-in functions for this purpose.\n\nint(): Converts a value to an integer.\nfloat(): Converts a value to a float.\nstr(): Converts a value to a string.\nbool(): Converts a value to a boolean.\n\nExample:\n\na = 10.5\nb = int(a)  # b is now 10\n\nc = \"123\"\nd = int(c)  # d is now 123\n\ne = \"True\"\nf = bool(e)  # f is now True\n\nChecking the types after conversion:\n\nprint(type(b))\nprint(type(d))\nprint(type(f))\n\n&lt;class 'int'&gt;\n&lt;class 'int'&gt;\n&lt;class 'bool'&gt;"
  },
  {
    "objectID": "05_Data_Types.html#operators-and-data-types",
    "href": "05_Data_Types.html#operators-and-data-types",
    "title": "5  Data Types",
    "section": "5.4 Operators and Data Types",
    "text": "5.4 Operators and Data Types\nOperators are used to perform operations on variables and values. Python supports various operators, and their behavior can differ based on the data types they operate on. Here, we will explore how operators work with different data types.\n\n5.4.1 Arithmetic Operators\nArithmetic operators are used to perform common mathematical operations such as addition, subtraction, multiplication, and division.\nExample with Integers:\n\na = 10\nb = 3\n\nprint(a + b) \nprint(a - b)  \nprint(a * b)  \nprint(a / b)  \nprint(a % b)  \nprint(a ** b) \nprint(a // b)  \n\n13\n7\n30\n3.3333333333333335\n1\n1000\n3\n\n\nExample with Floats:\n\nx = 10.5\ny = 3.2\n\nprint(x + y)  \nprint(x - y)  \nprint(x * y)  \nprint(x / y)\n\n13.7\n7.3\n33.6\n3.28125\n\n\n\n\n5.4.2 String Operators\nStrings can be manipulated using the + (concatenation) and * (repetition) operators.\nExample:\n\nstr1 = \"Hello\"\nstr2 = \"World\"\n\nprint(str1 + \" \" + str2)  \nprint(str1 * 3)  \n\nHello World\nHelloHelloHello\n\n\n\n\n5.4.3 Comparison Operators\nComparison operators are used to compare two values. They return a boolean value (True or False).\nExample with Integers and Floats:\n\na = 10\nb = 5\nc = 10.0\n\nprint(a == b)  \nprint(a != b)  \nprint(a &gt; b)   \nprint(a &lt; b)   \nprint(a &gt;= c)  \nprint(a &lt;= c) \n\nFalse\nTrue\nTrue\nFalse\nTrue\nTrue\n\n\nExample with Strings:\n\nstr1 = \"Hello\"\nstr2 = \"World\"\nstr3 = \"Hello\"\n\nprint(str1 == str2)  \nprint(str1 == str3)  \nprint(str1 != str2) \nprint(str1 &gt; str2)   # (Lexicographical comparison)\nprint(str1 &lt; str2)  \n\nFalse\nTrue\nTrue\nFalse\nTrue\n\n\n\n\n5.4.4 Logical Operators\nLogical operators are used to combine conditional statements.\nExample:\n\na = True\nb = False\n\nprint(a and b)  \nprint(a or b)  \nprint(not a)   \n\nFalse\nTrue\nFalse\n\n\nLogical operators can also be used with integers, where 0 is considered False and any non-zero value is considered True.\n\nx = 0\ny = 10\n\nprint(x and y)  \nprint(x or y)   \nprint(not x)  \n\n0\n10\nTrue"
  },
  {
    "objectID": "05_Data_Types.html#exercises",
    "href": "05_Data_Types.html#exercises",
    "title": "5  Data Types",
    "section": "5.5 Exercises",
    "text": "5.5 Exercises\n\nExercise 1: Identifying Data Types\nFor each of the following variables, use the type() function to determine its data type.\na = 42\nb = 3.14\nc = \"Python\"\nd = True\ne = None\n\n\nExercise 2: Type Conversion\nConvert the following values to the specified types and print the results.\n\nConvert x = 3.75 to an integer.\nConvert y = \"123\" to a float.\nConvert z = 0 to a boolean.\nConvert w = False to a string.\n\n\n\nExercise 3: Arithmetic Operations\nPerform the following arithmetic operations and print the results.\n\nAdd 15 and 23.\nSubtract 9 from 45.\nMultiply 7 by 8.\nDivide 20 by 4.\nCalculate the modulus of 27 and 4.\nRaise 2 to the power of 5.\nPerform floor division of 17 by 3.\n\n\n\nExercise 4: String Operations\nUse the appropriate operations to do the following and print the results.\n\nConcatenate the strings \"Data\" and \"Science\" with a space in between.\nRepeat the string \"Hello\" 5 times.\n\n\n\nExercise 5: Logical Operations\nEvaluate the following logical expressions and print the results.\n\nTrue and False\nTrue or False\nnot True\n(5 &gt; 3) and (2 &lt; 4)\n(10 == 10) or (5 != 5)\n\n\n\nExercise 6: Mixed-Type Operations\nDo the following operations and print the results.\n\nAdd an integer and a float: 7 + 3.14\nConcatenate a string and an integer (convert the integer to a string first): \"Age: \" + str(30)\nMultiply a string by an integer: \"Data\" * 4"
  },
  {
    "objectID": "06_Conditional_Statements.html#the-if-statement",
    "href": "06_Conditional_Statements.html#the-if-statement",
    "title": "6  Control Structures: Conditional Statements",
    "section": "6.1 The if Statement",
    "text": "6.1 The if Statement\nThe if statement is the most fundamental building block of conditional statements in Python. It allows the program to execute a block of code only if a specified condition is true. This section will delve deeper into the mechanics of the if statement, its syntax, and its practical applications.\n\nBasic Syntax\nThe basic syntax of an if statement in Python is straightforward. It consists of the keyword if followed by a condition, a colon, and an indented block of code that will be executed if the condition is true.\nSyntax:\nif condition:\n    statement(s)\n\ncondition: This is an expression that evaluates to either True or False.\nstatement(s): This is the block of code that will be executed if the condition evaluates to True.\n\nThe condition can be any expression that returns a Boolean value (i.e., True or False). If the condition evaluates to True, the indented block of code following the if statement is executed. If the condition evaluates to False, the block of code is skipped.\nExample:\n\nx = 10\nif x &gt; 5:\n    print(\"x is greater than 5\")\n\nx is greater than 5\n\n\nIn this example, the condition x &gt; 5 evaluates to True because 10 is greater than 5. Therefore, the code within the if block is executed, resulting in the output “x is greater than 5”.\n\n\nUsing Comparison Operators\nThe condition in an if statement often involves comparison operators. These operators compare two values and return True or False based on the comparison.\nCommon Comparison Operators:\n\n==: Equal to\n!=: Not equal to\n&gt;: Greater than\n&lt;: Less than\n&gt;=: Greater than or equal to\n&lt;=: Less than or equal to\n\nExamples:\n\n# Equal to\nx = 5\nif x == 5:\n    print(\"x is equal to 5\")\n\nx is equal to 5\n\n\n\n# Not equal to\ny = 10\nif y != 5:\n    print(\"y is not equal to 5\")\n\ny is not equal to 5\n\n\n\n# Greater than\na = 7\nif a &gt; 3:\n    print(\"a is greater than 3\")\n\na is greater than 3\n\n\n\n# Less than\nb = 2\nif b &lt; 5:\n    print(\"b is less than 5\")\n\nb is less than 5\n\n\n\n# Greater than or equal to\nc = 8\nif c &gt;= 8:\n    print(\"c is greater than or equal to 8\")\n\nc is greater than or equal to 8\n\n\n\n# Less than or equal to\nd = 4\nif d &lt;= 4:\n    print(\"d is less than or equal to 4\")\n\nd is less than or equal to 4\n\n\n\n\nCombining Conditions with Logical Operators\nSometimes, you need to check multiple conditions simultaneously. Python provides logical operators to combine multiple conditions.\nLogical Operators:\n\nand: Returns True if both conditions are True\nor: Returns True if at least one condition is True\nnot: Returns True if the condition is False\n\nExamples:\n\n# Using 'and' operator\nx = 10\ny = 20\nif x &gt; 5 and y &gt; 15:\n    print(\"Both conditions are true\")\n\nBoth conditions are true\n\n\n\n# Using 'or' operator\na = 5\nb = 10\nif a &gt; 7 or b &gt; 7:\n    print(\"At least one condition is true\")\n\nAt least one condition is true\n\n\n\n# Using 'not' operator\nc = 3\nif not c &gt; 5:\n    print(\"c is not greater than 5\")\n\nc is not greater than 5\n\n\nIn the first example, the condition x &gt; 5 and y &gt; 15 evaluates to True because both 10 &gt; 5 and 20 &gt; 15 are true. Therefore, the code within the if block is executed, resulting in the output “Both conditions are true”.\nIn the second example, the condition a &gt; 7 or b &gt; 7 evaluates to True because 10 &gt; 7 is true even though 5 &gt; 7 is false. Hence, the output is “At least one condition is true”.\nIn the third example, the condition not c &gt; 5 evaluates to True because c &gt; 5 is false, and not operator negates it. Therefore, the output is “c is not greater than 5”.\n\n\nNested if Statements\nYou can nest if statements within other if statements to create more complex decision structures. This means placing one if statement inside another if statement’s block of code.\nExample:\n\nx = 15\nif x &gt; 10:\n    print(\"x is greater than 10\")\n    if x &gt; 20:\n        print(\"x is also greater than 20\")\n\nx is greater than 10\n\n\nIn this example, the outer if statement checks if x is greater than 10. Since x is 15, the condition is true, and the code within the block is executed. Inside this block, there is another if statement that checks if x is greater than 20. Since 15 is not greater than 20, the block of the nested if statement is not executed."
  },
  {
    "objectID": "06_Conditional_Statements.html#the-else-clause",
    "href": "06_Conditional_Statements.html#the-else-clause",
    "title": "6  Control Structures: Conditional Statements",
    "section": "6.2 The else Clause",
    "text": "6.2 The else Clause\nThe else clause in Python provides an alternative block of code that will execute if the condition in the if statement evaluates to False. This allows for a two-way decision-making process: if the condition is true, one set of statements will run, otherwise, a different set of statements will run.\n\nBasic Syntax\nThe basic syntax for using the else clause follows directly after an if statement. The else clause must be at the same indentation level as the if statement, and its block of code must be indented further.\nSyntax:\nif condition:\n    statement(s)\nelse:\n    statement(s)\n\ncondition: This is an expression that evaluates to either True or False.\nstatement(s): This is the block of code that will be executed if the condition evaluates to False.\n\nExample:\n\nx = 3\nif x &gt; 5:\n    print(\"x is greater than 5\")\nelse:\n    print(\"x is not greater than 5\")\n\nx is not greater than 5\n\n\nIn this example, the condition x &gt; 5 evaluates to False because 3 is not greater than 5. Therefore, the code within the else block is executed, resulting in the output “x is not greater than 5”.\n\n\nNested else Clauses\nelse clauses can be nested within other conditional blocks to create more complex decision structures. This is useful when the logic requires multiple levels of checks.\nExample:\n\nx = 15\nif x &gt; 10:\n    print(\"x is greater than 10\")\n    if x &gt; 20:\n        print(\"x is also greater than 20\")\n    else:\n        print(\"x is between 11 and 20\")\nelse:\n    print(\"x is 10 or less\")\n\nx is greater than 10\nx is between 11 and 20\n\n\nIn this example, the outer if statement checks if x is greater than 10. Since x is 15, the condition is true, and the code within the block is executed. Inside this block, there is another if statement that checks if x is greater than 20. Since 15 is not greater than 20, the else block of the nested if statement is executed, resulting in the output “x is between 11 and 20”."
  },
  {
    "objectID": "06_Conditional_Statements.html#the-elif-clause",
    "href": "06_Conditional_Statements.html#the-elif-clause",
    "title": "6  Control Structures: Conditional Statements",
    "section": "6.3 The elif Clause",
    "text": "6.3 The elif Clause\nIn Python, the elif clause (short for “else if”) is used to check multiple conditions in a sequence. It allows you to add more than one conditional expression to an if statement, creating a chain of conditions that are evaluated in order. When one of these conditions evaluates to True, the corresponding block of code is executed, and the rest of the conditions are skipped.\n\nBasic Syntax\nThe elif clause follows the if clause and is used to test additional conditions if the previous conditions were not true. You can have as many elif clauses as you need, and an optional else clause can be included at the end to handle cases where none of the if or elif conditions are true.\nSyntax:\nif condition1:\n    statement(s)\nelif condition2:\n    statement(s)\nelif condition3:\n    statement(s)\n\ncondition1, condition2, condition3: These are expressions that evaluate to either True or False.\nstatement(s): These are the blocks of code that will be executed if the corresponding condition evaluates to True.\n\n\n\nUsing Multiple elif Clauses\nThe elif clause allows you to handle multiple potential cases in a clear and concise manner. The conditions are evaluated from top to bottom, and as soon as a True condition is found, the corresponding block of code is executed, and the rest of the conditions are skipped.\nExample:\n\nscore = 85\n\nif score &gt;= 90:\n    print(\"Grade: A\")\nelif score &gt;= 80:\n    print(\"Grade: B\")\nelif score &gt;= 70:\n    print(\"Grade: C\")\nelif score &gt;= 60:\n    print(\"Grade: D\")\nelif score &lt; 60:\n    print(\"Grade: F\")\n\nGrade: B\n\n\nIn this example, the program checks the score and assigns a grade based on predefined ranges. The conditions are evaluated in order: score &gt;= 90 is False, score &gt;= 80 is True, so the code within the elif score &gt;= 80 block is executed, resulting in the output “Grade: B”.\n\n\nCombining elif with else\nThe else clause is optional but often used at the end of an if-elif chain to catch any cases that do not meet the previous conditions. This ensures that there is always a defined action for any possible input.\nExample:\n\ntemperature = 75\n\nif temperature &gt; 85:\n    print(\"It's hot outside.\")\nelif temperature &gt; 65:\n    print(\"The weather is nice.\")\nelse:\n    print(\"It's cold outside.\")\n\nThe weather is nice.\n\n\nIn this example, the temperature is checked against three conditions. If the temperature is greater than 85, it prints “It’s hot outside.” If not, it checks if the temperature is greater than 65, printing “The weather is nice.” If neither condition is true, it defaults to printing “It’s cold outside.”\n\n\n6.3.4 Practical Applications\nExample: Speed Limit Checker\nLet’s create a program that checks a car’s speed and prints a message based on the speed.\n\nspeed = 55\n\nif speed &gt; 80:\n    print(\"You are speeding excessively.\")\nelif speed &gt; 60:\n    print(\"You are speeding.\")\nelif speed &gt; 40:\n    print(\"You are driving at a safe speed.\")\nelse:\n    print(\"You are driving below the speed limit.\")\n\nYou are driving at a safe speed.\n\n\nIn this program, the speed is checked against multiple conditions to provide feedback on the driving speed. The conditions are evaluated in sequence, and the appropriate message is printed based on the speed.\n\n\nNested elif Clauses\nSometimes, you may need to nest elif clauses within other if-elif-else blocks to handle more complex decision-making processes.\nExample: Admission Criteria\nLet’s create a program that checks admission criteria based on age and test scores.\nage = 18\ntest_score = 85\n\nif age &gt;= 18:\n    if test_score &gt;= 90:\n        print(\"Admitted with a scholarship.\")\n    elif test_score &gt;= 75:\n        print(\"Admitted.\")\n    else:\n        print(\"Not admitted due to low test score.\")\nelse:\n    print(\"Not admitted due to age requirement.\")\nIn this example, the outer if statement checks if the age is 18 or older. If true, it enters a nested if-elif-else block that checks the test score. Depending on the test score, it prints the appropriate admission status. If the age condition is not met, it prints “Not admitted due to age requirement.”\nThe elif clause in Python is a powerful tool for handling multiple conditions in a clear and structured manner. By combining if, elif, and else clauses, you can create flexible decision-making processes in your programs. This allows your code to react dynamically to a wide range of inputs and conditions, making it more robust and versatile."
  },
  {
    "objectID": "06_Conditional_Statements.html#conditional-expressions",
    "href": "06_Conditional_Statements.html#conditional-expressions",
    "title": "6  Control Structures: Conditional Statements",
    "section": "6.4 Conditional Expressions",
    "text": "6.4 Conditional Expressions\nPython also supports conditional expressions, which are a more concise way to write simple if-else statements.\nSyntax:\nvalue_if_true if condition else value_if_false\nExample:\n\nx = 5\nresult = \"Positive\" if x &gt; 0 else \"Non-positive\"\nprint(result)\n\nPositive\n\n\nThis example assigns the value “Positive” to the variable result if the condition x &gt; 0 is True, otherwise it assigns “Non-positive”. The output will be “Positive”."
  },
  {
    "objectID": "06_Conditional_Statements.html#exercises",
    "href": "06_Conditional_Statements.html#exercises",
    "title": "6  Control Structures: Conditional Statements",
    "section": "6.5 Exercises",
    "text": "6.5 Exercises\n\nExercise 1: Odd or Even\nWrite a program that checks if a number is odd or even using conditionals.\n\n\n\n\n\n\n\n\n\nExercise 2: Age Group\nWrite a program that categorizes a person’s age group using only if and else statements.\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 3: Positive, Negative, or Zero\nWrite a program that checks if a number is positive, negative, or zero. You must use at least one elif and one else statements."
  },
  {
    "objectID": "07_Loops.html#the-while-loop",
    "href": "07_Loops.html#the-while-loop",
    "title": "7  Control Structures: Loops",
    "section": "7.1 The while Loop",
    "text": "7.1 The while Loop\nThe while loop is one of the fundamental control structures in Python, allowing the repeated execution of a block of code as long as a specified condition is True. This type of loop is particularly useful when the number of iterations is not known beforehand and depends on dynamic conditions during runtime.\n\nBasic Syntax\nThe basic syntax of a while loop is:\nwhile condition:\n    statement(s)\n\ncondition: An expression that evaluates to True or False.\nstatement(s): The block of code that will be executed repeatedly as long as the condition is True.\n\n\n\nExample: Simple while Loop\nConsider a simple example where we print numbers from 1 to 5:\n\ni = 1\nwhile i &lt;= 5:\n    print(i)\n    i += 1\n\n1\n2\n3\n4\n5\n\n\nIn this example, the variable i is initialized to 1. The while loop checks if i is less than or equal to 5. If the condition is True, it prints the value of i and increments i by 1. The loop continues until i becomes greater than 5.\n\n\nInfinite Loops\nA common pitfall with while loops is the creation of infinite loops, which occur when the loop’s condition never becomes False. This can cause the program to run indefinitely, potentially causing it to become unresponsive.\nExample of an infinite loop:\nwhile True:\n    print(\"This loop will run forever.\")\nTo prevent infinite loops, ensure that the loop’s condition will eventually become False.\n\n\nwhile Loop with Else Clause\nPython allows an optional else clause with while loops. The else block is executed when the loop condition becomes False.\nExample:\n\ni = 1\nwhile i &lt;= 5:\n    print(i)\n    i += 1\nelse:\n    print(\"Loop ended naturally.\")\n\n1\n2\n3\n4\n5\nLoop ended naturally.\n\n\nIn this example, the else block is executed after the while loop finishes executing, printing “Loop ended naturally.”\n\n\nNested while Loops\nwhile loops can be nested within other loops to handle more complex tasks, such as iterating over multi-dimensional data structures.\nExample:\ni = 1\nwhile i &lt;= 3:\n    j = 1\n    while j &lt;= 3:\n        print(j)\n        j += 1\n    i += 1\nIn this example, the outer while loop iterates over the variable i from 1 to 3, and for each iteration, the inner while loop iterates over the variable j from 1 to 3.\n\n\nControlling Loop Execution\nPython provides several statements to control the execution of while loops:\n\nbreak: Terminates the loop prematurely.\ncontinue: Skips the rest of the loop body for the current iteration and proceeds to the next iteration.\npass: Does nothing and is used as a placeholder in loops or functions where code will be added later.\n\nExamples:\n\nUsing break:\n\ni = 1\nwhile i &lt;= 10:\n    if i == 5:\n        break\n    print(i)\n    i += 1\n\n1\n2\n3\n4\n\n\nUsing continue:\n\ni = 1\nwhile i &lt;= 10:\n    if i % 2 == 0:\n        i += 1\n        continue\n    print(i)\n    i += 1\n\n1\n3\n5\n7\n9\n\n\nUsing pass:\n\ni = 1\nwhile i &lt;= 10:\n    if i % 2 == 0:\n        pass  # Placeholder for future code\n    else:\n        print(i)\n    i += 1\n\n1\n3\n5\n7\n9"
  },
  {
    "objectID": "07_Loops.html#the-for-loop",
    "href": "07_Loops.html#the-for-loop",
    "title": "7  Control Structures: Loops",
    "section": "7.2 The for Loop",
    "text": "7.2 The for Loop\nThe for loop in Python is used for iterating over a sequence. Unlike the while loop, the for loop is preferred for its simplicity and readability when working with sequences. It provides a straightforward way to traverse elements in a collection, making it easier to write and understand.\n\nBasic Syntax\nThe basic syntax of a for loop is:\nfor variable in sequence:\n    statement(s)\n\nvariable: A variable that takes the value of each item in the sequence during iteration.\nsequence: A collection of items to iterate over (e.g., list, tuple, string, range).\nstatement(s): The block of code that will be executed for each item in the sequence.\n\n\n\nExample: Iterating Over a List\nConsider an example where we iterate over a list of numbers and print each number:\n\nnumbers = [1, 2, 3, 4, 5]\nfor num in numbers:\n    print(num)\n\n1\n2\n3\n4\n5\n\n\nIn this example, the for loop iterates over the list numbers, and the variable num takes the value of each item in the list during each iteration.\n\n\nThe range() Function\nThe range() function generates a sequence of numbers, which is particularly useful for creating loops that run a specific number of times. The range() function can take up to three arguments: start, stop, and step.\n\nstart: The starting value of the sequence (inclusive). Default is 0.\nstop: The ending value of the sequence (exclusive).\nstep: The difference between each pair of consecutive values. Default is 1.\n\nExample using range():\n\nfor i in range(1, 6):\n    print(i)\n\n1\n2\n3\n4\n5\n\n\nThis loop prints numbers from 1 to 5. The range(1, 6) function generates the numbers 1, 2, 3, 4, and 5.\n\n\nIterating Over Strings\nStrings are sequences of characters, and you can use a for loop to iterate over each character in a string.\nExample:\n\nmessage = \"Hello, World!\"\nfor char in message:\n    print(char)\n\nH\ne\nl\nl\no\n,\n \nW\no\nr\nl\nd\n!\n\n\nIn this example, the for loop iterates over the string message, and the variable char takes the value of each character in the string during each iteration.\n\n\nLoop Control Statements\nAs with while loops, Python provides several statements to control the execution of for loops:\n\nbreak: Terminates the loop prematurely.\ncontinue: Skips the rest of the code inside the loop for the current iteration and moves to the next iteration.\npass: Does nothing and is used as a placeholder in loops or functions where code will be added later.\n\nExamples:\n\nUsing break:\n\nfor i in range(1, 10):\n    if i == 5:\n        break\n    print(i)\n\n1\n2\n3\n4\n\n\nUsing continue:\n\nfor i in range(1, 10):\n    if i % 2 == 0:\n        continue\n    print(i)\n\n1\n3\n5\n7\n9\n\n\nUsing pass:\n\nfor i in range(1, 10):\n    if i % 2 == 0:\n        pass  # Placeholder for future code\n    else:\n        print(i)\n\n1\n3\n5\n7\n9\n\n\n\n\n\nPractical Applications\nfor loops are used in a wide range of practical applications, from data processing to generating patterns. Here are some examples:\nExample: Summing Numbers in a List\nCalculate the sum of all numbers in a list:\n\nnumbers = [23, 45, 12, 89, 34]\ntotal = 0\n\nfor num in numbers:\n    total += num\n\nprint(\"Sum:\", total)\n\nSum: 203\n\n\nIn this example, the for loop iterates over the list numbers, adding each number to the variable total, which holds the sum.\nExample: Finding the Maximum Value\nFind the maximum value in a list:\n\nnumbers = [23, 45, 12, 89, 34]\nmax_value = numbers[0]\n\nfor num in numbers:\n    if num &gt; max_value:\n        max_value = num\n\nprint(\"Maximum value:\", max_value)\n\nMaximum value: 89\n\n\nIn this example, the for loop iterates over the list numbers, updating the variable max_value if a larger number is found."
  },
  {
    "objectID": "07_Loops.html#exercises",
    "href": "07_Loops.html#exercises",
    "title": "7  Control Structures: Loops",
    "section": "7.3 Exercises",
    "text": "7.3 Exercises\n\nExercise 1: Counting Down\nWrite a program that counts down from 10 to 1 using a while loop.\n\n\n\n\n\n\n\n\n\n\nExercise 2: Sum of Positive Numbers\nWrite a program that repeatedly asks the user for a number until they enter a negative number. The program should then print the sum of all positive numbers entered.\n\n\n\n\n\n\ninput()\n\n\n\nThe input() function is used to display the given string to the console and wait for user input. The value entered by the user will be a string. Thus, the input must be converted to an int if an integer is needed in the rest of the code.\nFor this exercise, you can get the user input with the command\nnum = int(input(\"Enter a number (negative number to stop): \"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 3: Factorial Calculation\nWrite a program to calculate the factorial of a number using a while loop. Print the end result. Use an input() function as in Exercise 2.\n\n\n\n\n\n\n\n\n\n\n\nExercise 4: Guess the Number\nWrite a number guessing game where the program generates a random number between 1 and 100, and the user has to guess it. The program should give hints if the guess is too high or too low and keep asking until the user guesses correctly.\nUse the following code to generate the random number:\nimport random\nnumber = random.randint(1, 100)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 5: Sum of Even Numbers\nWrite a program to calculate the sum of all even numbers between 1 and 50.\n\n\n\n\n\n\n\n\n\nExercise 6: Prime Numbers\nWrite a program to print all prime numbers between 1 and 50 using a for loop and conditional statements."
  },
  {
    "objectID": "08_Functions.html#defining-a-function",
    "href": "08_Functions.html#defining-a-function",
    "title": "8  Functions",
    "section": "8.1 Defining a Function",
    "text": "8.1 Defining a Function\nTo define a function in Python, you use the def keyword, followed by the function name, parentheses (), and a colon :. The function body, which contains the code to be executed, is indented beneath the function definition.\nSyntax:\ndef function_name(parameters):\n    # Function body\n    statement(s)\nExample:\n\ndef greet():\n    print(\"Hello, World!\")\n\nIn this example, the function greet() is defined to print the message “Hello, World!” when called."
  },
  {
    "objectID": "08_Functions.html#calling-a-function",
    "href": "08_Functions.html#calling-a-function",
    "title": "8  Functions",
    "section": "8.2 Calling a Function",
    "text": "8.2 Calling a Function\nOnce a function is defined, it can be called by using its name followed by parentheses ().\nExample:\n\ngreet() \n\nHello, World!\n\n\nHere, the greet() function is invoked, and the message is displayed."
  },
  {
    "objectID": "08_Functions.html#function-arguments",
    "href": "08_Functions.html#function-arguments",
    "title": "8  Functions",
    "section": "8.3 Function Arguments",
    "text": "8.3 Function Arguments\nFunctions can accept input values called arguments or parameters, allowing them to perform operations based on the input provided. These arguments are specified within the parentheses when defining the function.\n\n8.3.1 Positional Arguments\nPositional arguments are the most straightforward type of arguments. They are assigned to parameters based on their position in the function call.\nExample:\n\ndef greet(name):\n    print(f\"Hello, {name}!\")\n\ngreet(\"Alice\")\n\nHello, Alice!\n\n\n\n\n\n\n\n\nf-strings\n\n\n\nThe argument in the print() function above is called an f-string. An f-string, introduced in Python 3.6, is a way to embed expressions inside string literals using curly braces {}. The f or F before the opening quote of the string indicates that it is an f-string. This allows you to include variables or expressions directly within the string, making string formatting more concise and readable.\n\n\nPositional arguments are assigned to function parameters by their order of appearance. This means the first argument in the function call is passed to the first parameter, the second argument to the second parameter, and so on.\nExample: Consider the following function definition:\n\ndef describe_person(name, age, city):\n    print(f\"{name} is {age} years old and lives in {city}.\")\n\nIf you call this function with the following positional arguments:\ndescribe_person(\"Alice\", 30, \"New York\")\nThe function execution will map the arguments as follows:\n\nname will be assigned the value \"Alice\"\nage will be assigned the value 30\ncity will be assigned the value \"New York\"\n\nThe output will be:\nAlice is 30 years old and lives in New York.\n\nImportance of Order\nSince positional arguments rely on the order in which they are passed, swapping the order can lead to incorrect or unintended results.\nExample of Incorrect Order:\ndescribe_person(30, \"Alice\", \"New York\")\nIn this case:\n\nname will be assigned 30\nage will be assigned \"Alice\"\ncity will be assigned \"New York\"\n\nThis will produce the incorrect output:\n30 is Alice years old and lives in New York.\n\n\n\n8.3.2 Keyword Arguments\nKeyword arguments allow you to specify the values for parameters by explicitly naming them in the function call, regardless of their order.\nExample:\n\ndef greet(name, message):\n    print(f\"{message}, {name}!\")\n\ngreet(name=\"Bob\", message=\"Good morning\") \n\nGood morning, Bob!\n\n\nThe function can also be called with the order swapped but with the correct names.\n\ngreet(message=\"Good morning\", name=\"Bob\") \n\nGood morning, Bob!\n\n\nHere, the arguments are passed by specifying the parameter names, providing flexibility in the order of arguments.\n\nCombining Positional and Keyword Arguments\nPositional arguments can be combined with keyword arguments. However, when mixing them, positional arguments must always come before keyword arguments.\nExample:\n\ndescribe_person(\"Alice\", age=30, city=\"New York\")\n\nAlice is 30 years old and lives in New York.\n\n\nThis call is valid and will produce the correct output, as the positional argument \"Alice\" is followed by keyword arguments for age and city.\n\n\n\n8.3.3 Default Arguments\nDefault arguments allow you to define a function with default values for certain parameters. If no argument is provided for a parameter with a default value, the default is used.\nExample:\n\ndef greet(name, message=\"Hello\"):\n    print(f\"{message}, {name}!\")\n\ngreet(\"Charlie\")  \ngreet(\"Charlie\", \"Goodbye\") \n\nHello, Charlie!\nGoodbye, Charlie!\n\n\nIn this example, the message parameter has a default value of \"Hello\", which is used when no other value is provided.\n\n\n8.3.4 Variable-Length Arguments\nIn Python, functions are not limited to accepting a fixed number of arguments. You can design functions to accept a variable number of arguments, allowing for greater flexibility and adaptability in different scenarios. Python provides two special types of arguments for this purpose: *args for positional arguments and **kwargs for keyword arguments. We will discuss *args here and come back to **kwargs in a later section after we discuss dictionaries.\n\n*args – Variable-Length Positional Arguments\nThe *args syntax allows a function to accept any number of positional arguments. When you use *args in a function definition, Python collects all the positional arguments passed into the function and stores them in a tuple, which is an ordered and immutable collection of items (discussed in Section 12). When you define a function with *args, it can handle calls with any number of positional arguments—from zero to many.\nExample:\n\ndef greet(*names):\n    for name in names:\n        print(f\"Hello, {name}!\")\n\nHere’s how this function works:\n\nIf you call greet(\"Alice\", \"Bob\", \"Charlie\"), the function will receive names as a tuple containing (\"Alice\", \"Bob\", \"Charlie\").\nThe function will then iterate over the tuple and print a greeting for each name.\n\n\ngreet(\"Alice\", \"Bob\", \"Charlie\")\n\nHello, Alice!\nHello, Bob!\nHello, Charlie!\n\n\n\nWhen to Use *args\n\nWhen the number of inputs is unknown: If you’re writing a function that might need to handle a varying number of inputs, *args is ideal.\nFor flexible APIs: In some cases, you want to provide a flexible API that allows users to pass in any number of arguments without enforcing a strict parameter count.\n\nExample: Imagine a function that calculates the total sum of an arbitrary number of numbers:\n\ndef calculate_sum(*numbers):\n    total = 0\n    for number in numbers:\n        total += number\n    return total\n\nprint(calculate_sum(1, 2, 3)) \nprint(calculate_sum(5, 10, 15, 20))\n\n6\n50\n\n\nThis function can sum any number of integers or floats, demonstrating how *args enables flexible input handling."
  },
  {
    "objectID": "08_Functions.html#return-values",
    "href": "08_Functions.html#return-values",
    "title": "8  Functions",
    "section": "8.4 Return Values",
    "text": "8.4 Return Values\nFunctions can return values using the return statement. The value returned can be assigned to a variable for further use in the program.\nExample:\n\ndef add(a, b):\n    return a + b\n\nresult = add(3, 4)\nprint(result) \n\n7\n\n\nHere, the add function returns the sum of a and b, which is then stored in the variable result.\n\n8.4.1 Returning Multiple Values\nIn Python, a function can return more than one value at a time, which is a feature that adds considerable flexibility to the way functions are used. When a function returns multiple values, it does so by returning a tuple. This allows you to return several related pieces of data from a single function call, without the need to explicitly create and manage a complex data structure.\n\nHow Multiple Return Values Work\nWhen a function is designed to return multiple values, it simply lists the values after the return keyword, separated by commas. Python automatically packages these values into a tuple. The caller of the function can then unpack this tuple into separate variables, each receiving one of the returned values.\nExample:\nConsider the following example:\n\ndef add_subtract(a, b):\n    return a + b, a - b\n\nIn this function:\n\na + b computes the sum of the two arguments a and b.\na - b computes the difference between a and b.\nBoth values are returned together as a tuple.\n\nWhen this function is called:\n\nsum_result, diff_result = add_subtract(10, 5)\nprint(sum_result)  \nprint(diff_result)  \n\n15\n5\n\n\nHere, the tuple (15, 5) is returned, and it is immediately unpacked into the variables sum_result and diff_result. This allows the caller to easily access each result separately.\n\n\nBenefits of Returning Multiple Values\nReturning multiple values from a function is particularly advantageous in situations where a single calculation or process naturally produces more than one result.\nExample 1: Mathematical Operations\n\ndef calculate_area_perimeter(length, width):\n    area = length * width\n    perimeter = 2 * (length + width)\n    return area, perimeter\n\narea, perimeter = calculate_area_perimeter(5, 3)\nprint(f\"Area: {area}, Perimeter: {perimeter}\")\n\nArea: 15, Perimeter: 16\n\n\nIn this example, the function calculate_area_perimeter returns both the area and perimeter of a rectangle. This allows the caller to retrieve and use both pieces of information with a single function call.\nExample 2: Finding Extremes\n\ndef find_extremes(numbers):\n    return max(numbers), min(numbers)\n\nmaximum, minimum = find_extremes([10, 20, 5, 30, 15])\nprint(f\"Maximum: {maximum}, Minimum: {minimum}\")\n\nMaximum: 30, Minimum: 5\n\n\nHere, the function find_extremes computes and returns both the maximum and minimum values from a list of numbers, making it easy to handle both results simultaneously.\n\n\nUnpacking Returned Values\nWhen a function returns multiple values, the caller can unpack these values into individual variables. This is done by assigning the function call to a tuple of variables corresponding to the number of values returned.\nExample:\n\nsum_result, diff_result = add_subtract(10, 5)\n\nIn this case, the returned tuple (15, 5) is unpacked into sum_result and diff_result, making the individual results accessible immediately.\n\n\nSingle Return Value with a Tuple\nIf needed, the function can return a tuple directly without unpacking it in the calling code. This can be useful when the function’s result is intended to be passed around or used as a single entity.\nExample:\n\nresult = add_subtract(10, 5)\nprint(result) \n\n(15, 5)\n\n\nHere, the entire tuple (15, 5) is returned as a single object and can be used as such."
  },
  {
    "objectID": "08_Functions.html#best-practices-in-function-design",
    "href": "08_Functions.html#best-practices-in-function-design",
    "title": "8  Functions",
    "section": "8.5 Best Practices in Function Design",
    "text": "8.5 Best Practices in Function Design\nDesigning functions effectively is crucial for writing clean, maintainable, and efficient code. Well-designed functions not only make your code easier to understand and use but also reduce the likelihood of bugs and make it easier to extend and modify your programs. Below are some best practices to follow when designing functions in Python.\n\nUse Descriptive Names\nA function’s name should clearly and concisely describe what the function does. Descriptive names make the code more readable and self-documenting, allowing others (and your future self) to understand the purpose of the function without needing extensive comments or external documentation.\nExample:\n\ndef calculate_average(scores):\n    return sum(scores) / len(scores)\n\nIn this example, the function name calculate_average clearly indicates that the function computes the average of a list of scores. Anyone reading the code can immediately grasp the function’s purpose without needing to examine its implementation.\nWhy This Matters:\n\nReadability: Descriptive names make your code easier to read and understand.\nMaintainability: When functions are clearly named, it’s easier to locate and update the appropriate function when changes are needed.\nCollaboration: In team settings, clear function names help other developers understand and use your code correctly, reducing the potential for errors.\n\n\n\nKeep Functions Focused\nA well-designed function should perform a single, clearly defined task or a set of closely related tasks. This practice, often referred to as the “Single Responsibility Principle,” ensures that your functions are simple, modular, and reusable.\nExample:\ndef read_file(file_path):\n    # Processing logic here\n    pass\n\ndef process_data(data):\n    # Processing logic here\n    pass\n\ndef write_file(file_path, data):\n    # Processing logic here\n    pass\n\n\n\n\n\n\npass\n\n\n\nIn Python, the pass keyword is used as a placeholder in your code. It allows you to write syntactically correct code blocks where no action is required. Essentially, pass does nothing when executed. It’s particularly useful in situations where you have a code structure that requires a statement, but you haven’t decided what the specific code should be yet.\nThink of pass as a placeholder in your code that let you outline the structure of your program without having to fill in the details immediately. This can be very helpful during the initial stages of writing or when planning out complex code.\n\n\nIn this example, each function is focused on a specific task: reading a file, processing data, and writing to a file. By keeping each function focused, the code becomes more modular and easier to maintain.\nWhy This Matters:\n\nSimplicity: Functions that do one thing are easier to understand, test, and debug.\nReusability: Focused functions are more likely to be reusable in different parts of your program or even in other projects.\nMaintainability: When functions are responsible for a single task, changes to one part of the code are less likely to have unintended side effects on other parts.\n\n\n\nAvoid Side Effects\nSide effects occur when a function modifies some state or interacts with outside elements like global variables, files, or databases, which are not directly related to its inputs and outputs. While side effects are sometimes necessary, minimizing them helps ensure that functions are predictable and easier to test.\nRecall that global and local variables were first discussed in Section 4.1.\nExample of a Function with Side Effects:\n\ntotal = 0\n\ndef add_to_total(amount):\n    global total\n    total += amount\n\nIn this example, the function add_to_total modifies the global variable total, which is a side effect. This can lead to unpredictable behavior, especially in larger programs where the global state is modified by multiple functions.\nBetter Approach:\n\ndef calculate_new_total(current_total, amount):\n    return current_total + amount\n\nIn this revised example, the function calculate_new_total returns a new total based on the inputs without modifying any external state. The function is now pure, meaning its output depends only on its inputs and has no side effects.\nWhy This Matters:\n\nPredictability: Functions without side effects are easier to reason about because they produce the same output for the same input every time.\nTestability: Pure functions are easier to test since you don’t need to set up or tear down any external state.\nDebugging: Functions that don’t cause side effects are less likely to introduce hidden bugs related to state changes elsewhere in the program.\n\n\n\nDocument Your Functions\nEven with descriptive names, adding docstrings to your functions is a good practice. A docstring provides a description of the function’s purpose, parameters, and return values, making it easier for others to use your function correctly.\nExample:\ndef calculate_average(scores):\n    \"\"\"\n    Calculates the average of a list of scores.\n\n    Parameters:\n    scores (list of int/float): A list of numeric scores.\n\n    Returns:\n    float: The average of the scores.\n    \"\"\"\n    return sum(scores) / len(scores)\nWhy This Matters:\n\nClarity: Docstrings clarify how to use the function, what inputs it expects, and what outputs it provides.\nCollaboration: Docstrings make it easier for others to understand and use your code.\nSelf-Documentation: Well-documented functions serve as a form of in-code documentation, reducing the need for external documentation.\n\nBy following these best practices in function design—using descriptive names, keeping functions focused, avoiding side effects, and documenting your functions—you can create Python code that is easier to read, maintain, and extend. These practices not only improve the quality of your code but also make it more robust and reliable, facilitating collaboration and reducing the likelihood of bugs."
  },
  {
    "objectID": "08_Functions.html#exercises",
    "href": "08_Functions.html#exercises",
    "title": "8  Functions",
    "section": "8.6 Exercises",
    "text": "8.6 Exercises\n\nExercise 1: Simple Greeting Function\nWrite a function greet_user that takes a user’s name as input and prints a greeting message.\n\n\nExercise 2: Arithmetic Function\nWrite a function calculate that takes two numbers and returns their sum, difference, product, and quotient.\n\n\nExercise 3: Temperature Conversion\nWrite a function convert_temperature that converts a temperature from Celsius to Fahrenheit.\n\n\nExercise 4: Flexible Function\nWrite a function summarize that can take any number of numerical arguments and returns their sum and average."
  },
  {
    "objectID": "09_Libraries.html#understanding-modules",
    "href": "09_Libraries.html#understanding-modules",
    "title": "9  Introduction to Modules and Libraries",
    "section": "9.1 Understanding Modules",
    "text": "9.1 Understanding Modules\nModules allow you to break your code into separate files, making it easier to manage and understand. A module can contain functions, classes, variables, and runnable code. By organizing your code into modules, you can create reusable components that can be easily imported into other projects.\nExample: Creating a Simple Module\nLet’s start by creating a simple module. Suppose we have a file named greetings.py:\n\n# greetings.py\n\ndef say_hello(name):\n    \"\"\"Print a friendly greeting.\"\"\"\n    return f\"Hello, {name}!\"\n\ndef say_goodbye(name):\n    \"\"\"Print a farewell message.\"\"\"\n    return f\"Goodbye, {name}!\"\n\nThis module contains two functions: say_hello and say_goodbye. You can import this module into another script and use these functions.\nExample: Using the Module\n# main.py\n\nimport greetings\n\nprint(greetings.say_hello(\"Alice\"))\nprint(greetings.say_goodbye(\"Alice\"))\nRunning main.py would output:\nHello, Alice!\nGoodbye, Alice!\n\n\n\n\n\n\nNote\n\n\n\nThe .py file that you are importing as a module needs to be in the same directory as the file you are importing the module into. In the example above, greetings.py and main.py needs to be in the same directory.\n\n\nHere, the greetings module is imported, and its functions are called to print personalized messages. This simple example demonstrates the power of modules in keeping your code organized and reusable."
  },
  {
    "objectID": "09_Libraries.html#importing-modules",
    "href": "09_Libraries.html#importing-modules",
    "title": "9  Introduction to Modules and Libraries",
    "section": "9.2 Importing Modules",
    "text": "9.2 Importing Modules\nModules are imported to gain access to their functions, classes, and variables. Python provides several methods for importing modules, each offering different levels of control and flexibility depending on your use case. Let’s explore these methods in detail.\n\nStandard Import\nThe most common way to import a module is by using a standard import statement. This method imports the entire module, making all of its contents accessible. However, to use any function or class from the module, you must prefix it with the module’s name. This ensures that there are no conflicts between functions or variables from different modules, as everything is neatly contained within its namespace.\nExample: Using math Module\n\nimport math\n\n# Accessing the square root function from the math module\nresult = math.sqrt(16)\nprint(result) \n\n4.0\n\n\nIn this example, the math module is imported, and we use the sqrt function by referencing it through the module’s name.\n\n\nImporting Specific Functions or Classes\nSometimes, you may only need a specific function, class, or variable from a module. Python allows you to import only what you need, which can make your code cleaner and more efficient. When you import specific items, you don’t need to prefix them with the module’s name, as they are directly accessible.\nExample: Importing sqrt from math\n\nfrom math import sqrt\n\n# Directly using the imported sqrt function\nresult = sqrt(16)\nprint(result) \n\n4.0\n\n\nThis method is particularly useful when you need to use a specific function frequently and want to avoid repeatedly typing the module name. However, it’s important to be cautious with this approach, as it can lead to naming conflicts if different modules contain functions or variables with the same name.\nYou can import multiple items from a module by separating them with commas:\n\nfrom math import sqrt, pi\n\n# Using both imported items directly\nprint(sqrt(25))  \nprint(pi)       \n\n5.0\n3.141592653589793\n\n\n\n\nImporting All Names with *\nIn certain cases, you might want to import everything from a module, making all its functions and variables directly accessible without needing to prefix them with the module’s name. This can be done using the * wildcard. However, this method is generally discouraged because it can lead to unexpected name conflicts and make the code harder to understand and debug.\nExample: Importing All from math\n\nfrom math import *\n\n# Using functions and constants directly\nprint(sqrt(16))  \nprint(pi)       \n\n4.0\n3.141592653589793\n\n\nWhile this approach can save typing and is convenient in small scripts or interactive sessions, it is not recommended for larger programs or libraries, where clarity and maintainability are critical.\n\n\nImport with Alias\nModules can sometimes have long names, or you may want to avoid conflicts between modules that share the same name. In these situations, you can import a module under a different name, known as an alias. This allows you to reference the module using a shorter or more descriptive name, making your code more concise and readable.\nExample: Importing math with an Alias\n\nimport math as m\n\n# Using the alias to access functions from the math module\nresult = m.sqrt(16)\nprint(result) \n\n4.0\n\n\nAliases are particularly useful when working with libraries that have long names or when you frequently use a module in your code. They help in maintaining readability while reducing the amount of typing required.\nExample: Avoiding Name Conflicts with Aliases\n\nimport matplotlib.pyplot as plt\n\n# Using aliases in place of longer name\nplt.plot([1, 2, 3], [4, 5, 6])\n\n\n\n\n\n\n\n\n\n\nInstalling matplotlib\n\n\n\nMost installs of Python do not include matplotlib as a base library. You may need to install it. Open up a terminal. Run the following code to install matplotlib.\npip install matplotlib --user\nNote that if you are using a virtual environment, you will need to make sure the virtual environment is activated first.\n\n\n\n\nImporting Modules from a Package\nPython also supports importing modules from a package, which is a collection of modules organized under a common namespace. Packages help in organizing related modules and can be imported similarly to regular modules.\nExample: Importing from a Package\n\nfrom os import path\n\n# Using the path module from the os package\nprint(path.exists(\"example.txt\")) \n\nFalse\n\n\nIn this example, the path module is imported from the os package, and its exists function is used to check if a file exists. Packages are an essential part of Python’s ecosystem, allowing you to organize and distribute your code effectively."
  },
  {
    "objectID": "09_Libraries.html#built-in-libraries",
    "href": "09_Libraries.html#built-in-libraries",
    "title": "9  Introduction to Modules and Libraries",
    "section": "9.3 Built-in Libraries",
    "text": "9.3 Built-in Libraries\nPython comes with a rich set of built-in libraries that cover a wide range of functionalities, from mathematical operations to file handling and beyond. Let’s explore a few common libraries that you will frequently use in your programming journey.\n\nThe math Library\nAs you have already seen, the math library provides mathematical functions and constants.\nExample: Basic Usage of math Library\n\nimport math\n\n# Using constants\nprint(math.pi)\n\n# Using functions\nprint(math.factorial(5))\nprint(math.sqrt(25))\n\n3.141592653589793\n120\n5.0\n\n\n\n\nThe random Library\nThe random library is used for generating random numbers and making random selections.\nExample: Using random Library\n\nimport random\n\n# Generating a random number between 1 and 10\nprint(random.randint(1, 10))  \n\n# Picking a random choice from a list\nchoices = ['apple', 'banana', 'cherry']\nprint(random.choice(choices)) \n\n6\ncherry\n\n\nThis library is particularly useful in simulations, games, and scenarios where randomness is needed."
  },
  {
    "objectID": "09_Libraries.html#creating-custom-modules",
    "href": "09_Libraries.html#creating-custom-modules",
    "title": "9  Introduction to Modules and Libraries",
    "section": "9.4 Creating Custom Modules",
    "text": "9.4 Creating Custom Modules\nCreating your own modules allows you to encapsulate code that can be reused across multiple projects. As you progress in your coding journey, you’ll find this practice invaluable for maintaining clean and organized code.\nExample: Building a Utility Module\nLet’s create a module named utils.py that contains some utility functions:\n\n# utils.py\n\ndef reverse_string(s):\n    \"\"\"Reverse a given string.\"\"\"\n    return s[::-1]\n\ndef is_palindrome(s):\n    \"\"\"Check if a string is a palindrome.\"\"\"\n    return s == s[::-1]\n\nYou can now import and use these functions in any script:\n# main.py\n\nimport utils\n\nword = \"level\"\nprint(utils.reverse_string(word)) \nprint(utils.is_palindrome(word))  \nlevel\nTrue"
  },
  {
    "objectID": "09_Libraries.html#best-practices-for-modules-and-libraries",
    "href": "09_Libraries.html#best-practices-for-modules-and-libraries",
    "title": "9  Introduction to Modules and Libraries",
    "section": "9.5 Best Practices for Modules and Libraries",
    "text": "9.5 Best Practices for Modules and Libraries\nWhen working with modules and libraries in Python, following best practices is essential for creating code that is both maintainable and user-friendly. One of the most important practices is to use descriptive names for your modules. The name of a module should clearly convey its purpose and functionality, making it easier for others (and yourself) to understand what the module does at a glance. For example, a module named math_operations is far more informative than a generic name like utils, as it immediately indicates that the module contains functions related to mathematical operations. Descriptive naming helps prevent confusion, especially in larger projects where multiple modules are used.\nIn addition to naming, keeping functions within a module focused on a single, well-defined task is crucial. Each function should do one thing and do it well. This approach not only makes your code easier to test and debug but also enhances its reusability. For instance, a function that calculates the average of a list of numbers should not also be responsible for reading the numbers from a file. By adhering to the principle of single responsibility, you ensure that each function is modular, making it easier to mix and match functions across different modules and projects.\nDocumentation is another critical aspect of writing good modules. Providing clear and comprehensive docstrings for your modules, functions, and classes is essential for making your code accessible to others. Docstrings should explain what the code does, how to use it, and any important details that users need to be aware of. Well-documented code not only helps others understand and use your modules but also serves as a valuable reference for yourself when you return to the code after some time. Good documentation is a sign of professionalism and care in coding, making your work more reliable and easier to maintain.\nFinally, it is important to avoid side effects in your modules. Side effects occur when a module executes code automatically upon being imported, such as modifying global variables or performing I/O operations. This can lead to unpredictable behavior and bugs, especially if the user is unaware of these side effects. To prevent this, modules should generally be passive, only providing functions and classes without executing any code unless explicitly intended."
  },
  {
    "objectID": "09_Libraries.html#exercises",
    "href": "09_Libraries.html#exercises",
    "title": "9  Introduction to Modules and Libraries",
    "section": "9.6 Exercises",
    "text": "9.6 Exercises\n\nExcersice 1: Creating a Module\nCreate a module arithmetic.py that contains functions for addition, subtraction, multiplication, and division. Write a script that imports this module and performs these operations on user-provided inputs.\n\n\nExcersice 2: Using Built-in Libraries\nWrite a script that uses the random library to generate a random integer and then uses the math library to find the square root of this integer.\n\n\nExcersice 3: Module Compositio\nCreate a module geometry.py that contains functions to calculate the area and perimeter of different shapes, such as rectangles, circles, and triangles. Write a script that imports this module and allows the user to input the dimensions of a shape, then outputs the calculated area and perimeter.\n\n\nExcersice 4: Creating a Custom Math Library\nDevelop a custom math module custom_math.py that includes functions for basic arithmetic operations, factorial calculation, and prime number checking. Extend the module by adding a function to calculate the greatest common divisor (GCD) of two numbers. Write a script to demonstrate the usage of each function in the module."
  }
]